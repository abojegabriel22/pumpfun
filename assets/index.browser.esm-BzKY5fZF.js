import{L as Vn,ap as Zr,q as io,aq as Yr,ar as re}from"./index-PvtrSBdy.js";import{r as Xr,a as co}from"./index-HINHnEP6.js";var zt,ao=new Uint8Array(16);function Jr(){if(!zt&&(zt=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!zt))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return zt(ao)}const uo=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function an(r){return typeof r=="string"&&uo.test(r)}var be=[];for(var yn=0;yn<256;++yn)be.push((yn+256).toString(16).substr(1));function un(r){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(be[r[e+0]]+be[r[e+1]]+be[r[e+2]]+be[r[e+3]]+"-"+be[r[e+4]]+be[r[e+5]]+"-"+be[r[e+6]]+be[r[e+7]]+"-"+be[r[e+8]]+be[r[e+9]]+"-"+be[r[e+10]]+be[r[e+11]]+be[r[e+12]]+be[r[e+13]]+be[r[e+14]]+be[r[e+15]]).toLowerCase();if(!an(t))throw TypeError("Stringified UUID is invalid");return t}var fr,bn,mn=0,wn=0;function lo(r,e,t){var n=e&&t||0,s=e||new Array(16);r=r||{};var o=r.node||fr,i=r.clockseq!==void 0?r.clockseq:bn;if(o==null||i==null){var a=r.random||(r.rng||Jr)();o==null&&(o=fr=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=bn=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),f=r.nsecs!==void 0?r.nsecs:wn+1,b=c-mn+(f-wn)/1e4;if(b<0&&r.clockseq===void 0&&(i=i+1&16383),(b<0||c>mn)&&r.nsecs===void 0&&(f=0),f>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");mn=c,wn=f,bn=i,c+=122192928e5;var k=((c&268435455)*1e4+f)%4294967296;s[n++]=k>>>24&255,s[n++]=k>>>16&255,s[n++]=k>>>8&255,s[n++]=k&255;var p=c/4294967296*1e4&268435455;s[n++]=p>>>8&255,s[n++]=p&255,s[n++]=p>>>24&15|16,s[n++]=p>>>16&255,s[n++]=i>>>8|128,s[n++]=i&255;for(var g=0;g<6;++g)s[n+g]=o[g];return e||un(s)}function Qr(r){if(!an(r))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(r.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(r.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(r.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(r.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(r.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function fo(r){r=unescape(encodeURIComponent(r));for(var e=[],t=0;t<r.length;++t)e.push(r.charCodeAt(t));return e}var ho="6ba7b810-9dad-11d1-80b4-00c04fd430c8",go="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function es(r,e,t){function n(s,o,i,a){if(typeof s=="string"&&(s=fo(s)),typeof o=="string"&&(o=Qr(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+s.length);if(c.set(o),c.set(s,o.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var f=0;f<16;++f)i[a+f]=c[f];return i}return un(c)}try{n.name=r}catch{}return n.DNS=ho,n.URL=go,n}function po(r){if(typeof r=="string"){var e=unescape(encodeURIComponent(r));r=new Uint8Array(e.length);for(var t=0;t<e.length;++t)r[t]=e.charCodeAt(t)}return yo(bo(mo(r),r.length*8))}function yo(r){for(var e=[],t=r.length*32,n="0123456789abcdef",s=0;s<t;s+=8){var o=r[s>>5]>>>s%32&255,i=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);e.push(i)}return e}function ts(r){return(r+64>>>9<<4)+14+1}function bo(r,e){r[e>>5]|=128<<e%32,r[ts(e)-1]=e;for(var t=1732584193,n=-271733879,s=-1732584194,o=271733878,i=0;i<r.length;i+=16){var a=t,c=n,f=s,b=o;t=Ee(t,n,s,o,r[i],7,-680876936),o=Ee(o,t,n,s,r[i+1],12,-389564586),s=Ee(s,o,t,n,r[i+2],17,606105819),n=Ee(n,s,o,t,r[i+3],22,-1044525330),t=Ee(t,n,s,o,r[i+4],7,-176418897),o=Ee(o,t,n,s,r[i+5],12,1200080426),s=Ee(s,o,t,n,r[i+6],17,-1473231341),n=Ee(n,s,o,t,r[i+7],22,-45705983),t=Ee(t,n,s,o,r[i+8],7,1770035416),o=Ee(o,t,n,s,r[i+9],12,-1958414417),s=Ee(s,o,t,n,r[i+10],17,-42063),n=Ee(n,s,o,t,r[i+11],22,-1990404162),t=Ee(t,n,s,o,r[i+12],7,1804603682),o=Ee(o,t,n,s,r[i+13],12,-40341101),s=Ee(s,o,t,n,r[i+14],17,-1502002290),n=Ee(n,s,o,t,r[i+15],22,1236535329),t=xe(t,n,s,o,r[i+1],5,-165796510),o=xe(o,t,n,s,r[i+6],9,-1069501632),s=xe(s,o,t,n,r[i+11],14,643717713),n=xe(n,s,o,t,r[i],20,-373897302),t=xe(t,n,s,o,r[i+5],5,-701558691),o=xe(o,t,n,s,r[i+10],9,38016083),s=xe(s,o,t,n,r[i+15],14,-660478335),n=xe(n,s,o,t,r[i+4],20,-405537848),t=xe(t,n,s,o,r[i+9],5,568446438),o=xe(o,t,n,s,r[i+14],9,-1019803690),s=xe(s,o,t,n,r[i+3],14,-187363961),n=xe(n,s,o,t,r[i+8],20,1163531501),t=xe(t,n,s,o,r[i+13],5,-1444681467),o=xe(o,t,n,s,r[i+2],9,-51403784),s=xe(s,o,t,n,r[i+7],14,1735328473),n=xe(n,s,o,t,r[i+12],20,-1926607734),t=ke(t,n,s,o,r[i+5],4,-378558),o=ke(o,t,n,s,r[i+8],11,-2022574463),s=ke(s,o,t,n,r[i+11],16,1839030562),n=ke(n,s,o,t,r[i+14],23,-35309556),t=ke(t,n,s,o,r[i+1],4,-1530992060),o=ke(o,t,n,s,r[i+4],11,1272893353),s=ke(s,o,t,n,r[i+7],16,-155497632),n=ke(n,s,o,t,r[i+10],23,-1094730640),t=ke(t,n,s,o,r[i+13],4,681279174),o=ke(o,t,n,s,r[i],11,-358537222),s=ke(s,o,t,n,r[i+3],16,-722521979),n=ke(n,s,o,t,r[i+6],23,76029189),t=ke(t,n,s,o,r[i+9],4,-640364487),o=ke(o,t,n,s,r[i+12],11,-421815835),s=ke(s,o,t,n,r[i+15],16,530742520),n=ke(n,s,o,t,r[i+2],23,-995338651),t=Be(t,n,s,o,r[i],6,-198630844),o=Be(o,t,n,s,r[i+7],10,1126891415),s=Be(s,o,t,n,r[i+14],15,-1416354905),n=Be(n,s,o,t,r[i+5],21,-57434055),t=Be(t,n,s,o,r[i+12],6,1700485571),o=Be(o,t,n,s,r[i+3],10,-1894986606),s=Be(s,o,t,n,r[i+10],15,-1051523),n=Be(n,s,o,t,r[i+1],21,-2054922799),t=Be(t,n,s,o,r[i+8],6,1873313359),o=Be(o,t,n,s,r[i+15],10,-30611744),s=Be(s,o,t,n,r[i+6],15,-1560198380),n=Be(n,s,o,t,r[i+13],21,1309151649),t=Be(t,n,s,o,r[i+4],6,-145523070),o=Be(o,t,n,s,r[i+11],10,-1120210379),s=Be(s,o,t,n,r[i+2],15,718787259),n=Be(n,s,o,t,r[i+9],21,-343485551),t=Qe(t,a),n=Qe(n,c),s=Qe(s,f),o=Qe(o,b)}return[t,n,s,o]}function mo(r){if(r.length===0)return[];for(var e=r.length*8,t=new Uint32Array(ts(e)),n=0;n<e;n+=8)t[n>>5]|=(r[n/8]&255)<<n%32;return t}function Qe(r,e){var t=(r&65535)+(e&65535),n=(r>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function wo(r,e){return r<<e|r>>>32-e}function ln(r,e,t,n,s,o){return Qe(wo(Qe(Qe(e,r),Qe(n,o)),s),t)}function Ee(r,e,t,n,s,o,i){return ln(e&t|~e&n,r,e,s,o,i)}function xe(r,e,t,n,s,o,i){return ln(e&n|t&~n,r,e,s,o,i)}function ke(r,e,t,n,s,o,i){return ln(e^t^n,r,e,s,o,i)}function Be(r,e,t,n,s,o,i){return ln(t^(e|~n),r,e,s,o,i)}var So=es("v3",48,po);function Eo(r,e,t){r=r||{};var n=r.random||(r.rng||Jr)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var s=0;s<16;++s)e[t+s]=n[s];return e}return un(n)}function xo(r,e,t,n){switch(r){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function Sn(r,e){return r<<e|r>>>32-e}function ko(r){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var s=0;s<n.length;++s)r.push(n.charCodeAt(s))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,i=Math.ceil(o/16),a=new Array(i),c=0;c<i;++c){for(var f=new Uint32Array(16),b=0;b<16;++b)f[b]=r[c*64+b*4]<<24|r[c*64+b*4+1]<<16|r[c*64+b*4+2]<<8|r[c*64+b*4+3];a[c]=f}a[i-1][14]=(r.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(r.length-1)*8&4294967295;for(var k=0;k<i;++k){for(var p=new Uint32Array(80),g=0;g<16;++g)p[g]=a[k][g];for(var E=16;E<80;++E)p[E]=Sn(p[E-3]^p[E-8]^p[E-14]^p[E-16],1);for(var m=t[0],I=t[1],C=t[2],q=t[3],U=t[4],H=0;H<80;++H){var j=Math.floor(H/20),J=Sn(m,5)+xo(j,I,C,q)+U+e[j]+p[H]>>>0;U=q,q=C,C=Sn(I,30)>>>0,I=m,m=J}t[0]=t[0]+m>>>0,t[1]=t[1]+I>>>0,t[2]=t[2]+C>>>0,t[3]=t[3]+q>>>0,t[4]=t[4]+U>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Bo=es("v5",80,ko);const _o="00000000-0000-0000-0000-000000000000";function Ao(r){if(!an(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const vo=Object.freeze(Object.defineProperty({__proto__:null,NIL:_o,parse:Qr,stringify:un,v1:lo,v3:So,v4:Eo,v5:Bo,validate:an,version:Ao},Symbol.toStringTag,{value:"Module"})),ht=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ut(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Dn(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function at(r,...e){if(!Ut(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function ns(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Dn(r.outputLen),Dn(r.blockLen)}function Gt(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Io(r,e){at(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function kt(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function En(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function Pe(r,e){return r<<32-e|r>>>e}const rs=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ro=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function it(r){if(at(r),rs)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=Ro[r[t]];return e}const ze={_0:48,_9:57,A:65,F:70,a:97,f:102};function dr(r){if(r>=ze._0&&r<=ze._9)return r-ze._0;if(r>=ze.A&&r<=ze.F)return r-(ze.A-10);if(r>=ze.a&&r<=ze.f)return r-(ze.a-10)}function Zt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(rs)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){const i=dr(r.charCodeAt(o)),a=dr(r.charCodeAt(o+1));if(i===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[s]=i*16+a}return n}function Co(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Gn(r){return typeof r=="string"&&(r=Co(r)),at(r),r}function qe(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];at(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const o=r[n];t.set(o,s),s+=o.length}return t}class ss{}function os(r){const e=n=>r().update(Gn(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Zn(r=32){if(ht&&typeof ht.getRandomValues=="function")return ht.getRandomValues(new Uint8Array(r));if(ht&&typeof ht.randomBytes=="function")return Uint8Array.from(ht.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}function To(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(t>>s&o),a=Number(t&o),c=n?4:0,f=n?0:4;r.setUint32(e+c,i,n),r.setUint32(e+f,a,n)}function Lo(r,e,t){return r&e^~r&t}function Uo(r,e,t){return r&e^r&t^e&t}class is extends ss{constructor(e,t,n,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=En(this.buffer)}update(e){Gt(this),e=Gn(e),at(e);const{view:t,buffer:n,blockLen:s}=this,o=e.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=En(e);for(;s<=o-i;i+=s)this.process(c,i);continue}n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Gt(this),Io(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:o}=this;let{pos:i}=this;t[i++]=128,kt(this.buffer.subarray(i)),this.padOffset>s-i&&(this.process(n,0),i=0);for(let k=i;k<s;k++)t[k]=0;To(n,s-8,BigInt(this.length*8),o),this.process(n,0);const a=En(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=c/4,b=this.get();if(f>b.length)throw new Error("_sha2: outputLen bigger than state");for(let k=0;k<f;k++)a.setUint32(4*k,b[k],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:o,destroyed:i,pos:a}=this;return e.destroyed=i,e.finished=o,e.length=s,e.pos=a,s%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Ve=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_e=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Mt=BigInt(2**32-1),hr=BigInt(32);function Oo(r,e=!1){return e?{h:Number(r&Mt),l:Number(r>>hr&Mt)}:{h:Number(r>>hr&Mt)|0,l:Number(r&Mt)|0}}function No(r,e=!1){const t=r.length;let n=new Uint32Array(t),s=new Uint32Array(t);for(let o=0;o<t;o++){const{h:i,l:a}=Oo(r[o],e);[n[o],s[o]]=[i,a]}return[n,s]}const gr=(r,e,t)=>r>>>t,pr=(r,e,t)=>r<<32-t|e>>>t,gt=(r,e,t)=>r>>>t|e<<32-t,pt=(r,e,t)=>r<<32-t|e>>>t,Kt=(r,e,t)=>r<<64-t|e>>>t-32,Ht=(r,e,t)=>r>>>t-32|e<<64-t;function Me(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Po=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),qo=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Fo=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Do=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,zo=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Mo=(r,e,t,n,s,o)=>e+t+n+s+o+(r/2**32|0)|0,Ko=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ge=new Uint32Array(64);class Ho extends is{constructor(e=32){super(64,e,8,!1),this.A=Ve[0]|0,this.B=Ve[1]|0,this.C=Ve[2]|0,this.D=Ve[3]|0,this.E=Ve[4]|0,this.F=Ve[5]|0,this.G=Ve[6]|0,this.H=Ve[7]|0}get(){const{A:e,B:t,C:n,D:s,E:o,F:i,G:a,H:c}=this;return[e,t,n,s,o,i,a,c]}set(e,t,n,s,o,i,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=a|0,this.H=c|0}process(e,t){for(let k=0;k<16;k++,t+=4)Ge[k]=e.getUint32(t,!1);for(let k=16;k<64;k++){const p=Ge[k-15],g=Ge[k-2],E=Pe(p,7)^Pe(p,18)^p>>>3,m=Pe(g,17)^Pe(g,19)^g>>>10;Ge[k]=m+Ge[k-7]+E+Ge[k-16]|0}let{A:n,B:s,C:o,D:i,E:a,F:c,G:f,H:b}=this;for(let k=0;k<64;k++){const p=Pe(a,6)^Pe(a,11)^Pe(a,25),g=b+p+Lo(a,c,f)+Ko[k]+Ge[k]|0,m=(Pe(n,2)^Pe(n,13)^Pe(n,22))+Uo(n,s,o)|0;b=f,f=c,c=a,a=i+g|0,i=o,o=s,s=n,n=g+m|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,a=a+this.E|0,c=c+this.F|0,f=f+this.G|0,b=b+this.H|0,this.set(n,s,o,i,a,c,f,b)}roundClean(){kt(Ge)}destroy(){this.set(0,0,0,0,0,0,0,0),kt(this.buffer)}}const cs=No(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),$o=cs[0],Wo=cs[1],Ze=new Uint32Array(80),Ye=new Uint32Array(80);class jo extends is{constructor(e=64){super(128,e,16,!1),this.Ah=_e[0]|0,this.Al=_e[1]|0,this.Bh=_e[2]|0,this.Bl=_e[3]|0,this.Ch=_e[4]|0,this.Cl=_e[5]|0,this.Dh=_e[6]|0,this.Dl=_e[7]|0,this.Eh=_e[8]|0,this.El=_e[9]|0,this.Fh=_e[10]|0,this.Fl=_e[11]|0,this.Gh=_e[12]|0,this.Gl=_e[13]|0,this.Hh=_e[14]|0,this.Hl=_e[15]|0}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:f,El:b,Fh:k,Fl:p,Gh:g,Gl:E,Hh:m,Hl:I}=this;return[e,t,n,s,o,i,a,c,f,b,k,p,g,E,m,I]}set(e,t,n,s,o,i,a,c,f,b,k,p,g,E,m,I){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=f|0,this.El=b|0,this.Fh=k|0,this.Fl=p|0,this.Gh=g|0,this.Gl=E|0,this.Hh=m|0,this.Hl=I|0}process(e,t){for(let U=0;U<16;U++,t+=4)Ze[U]=e.getUint32(t),Ye[U]=e.getUint32(t+=4);for(let U=16;U<80;U++){const H=Ze[U-15]|0,j=Ye[U-15]|0,J=gt(H,j,1)^gt(H,j,8)^gr(H,j,7),se=pt(H,j,1)^pt(H,j,8)^pr(H,j,7),Y=Ze[U-2]|0,y=Ye[U-2]|0,w=gt(Y,y,19)^Kt(Y,y,61)^gr(Y,y,6),T=pt(Y,y,19)^Ht(Y,y,61)^pr(Y,y,6),R=Fo(se,T,Ye[U-7],Ye[U-16]),B=Do(R,J,w,Ze[U-7],Ze[U-16]);Ze[U]=B|0,Ye[U]=R|0}let{Ah:n,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:f,Dl:b,Eh:k,El:p,Fh:g,Fl:E,Gh:m,Gl:I,Hh:C,Hl:q}=this;for(let U=0;U<80;U++){const H=gt(k,p,14)^gt(k,p,18)^Kt(k,p,41),j=pt(k,p,14)^pt(k,p,18)^Ht(k,p,41),J=k&g^~k&m,se=p&E^~p&I,Y=zo(q,j,se,Wo[U],Ye[U]),y=Mo(Y,C,H,J,$o[U],Ze[U]),w=Y|0,T=gt(n,s,28)^Kt(n,s,34)^Kt(n,s,39),R=pt(n,s,28)^Ht(n,s,34)^Ht(n,s,39),B=n&o^n&a^o&a,x=s&i^s&c^i&c;C=m|0,q=I|0,m=g|0,I=E|0,g=k|0,E=p|0,{h:k,l:p}=Me(f|0,b|0,y|0,w|0),f=a|0,b=c|0,a=o|0,c=i|0,o=n|0,i=s|0;const v=Po(w,R,x);n=qo(v,y,T,B),s=v|0}({h:n,l:s}=Me(this.Ah|0,this.Al|0,n|0,s|0)),{h:o,l:i}=Me(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=Me(this.Ch|0,this.Cl|0,a|0,c|0),{h:f,l:b}=Me(this.Dh|0,this.Dl|0,f|0,b|0),{h:k,l:p}=Me(this.Eh|0,this.El|0,k|0,p|0),{h:g,l:E}=Me(this.Fh|0,this.Fl|0,g|0,E|0),{h:m,l:I}=Me(this.Gh|0,this.Gl|0,m|0,I|0),{h:C,l:q}=Me(this.Hh|0,this.Hl|0,C|0,q|0),this.set(n,s,o,i,a,c,f,b,k,p,g,E,m,I,C,q)}roundClean(){kt(Ze,Ye)}destroy(){kt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const as=os(()=>new Ho),Vo=os(()=>new jo);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yn=BigInt(0),zn=BigInt(1);function ct(r,e=""){if(typeof r!="boolean"){const t=e&&`"${e}"`;throw new Error(t+"expected boolean, got type="+typeof r)}return r}function Oe(r,e,t=""){const n=Ut(r),s=r?.length,o=e!==void 0;if(!n||o&&s!==e){const i=t&&`"${t}" `,a=o?` of length ${e}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(i+"expected Uint8Array"+a+", got "+c)}return r}function $t(r){const e=r.toString(16);return e.length&1?"0"+e:e}function us(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Yn:BigInt("0x"+r)}function fn(r){return us(it(r))}function Tt(r){return at(r),us(it(Uint8Array.from(r).reverse()))}function Xn(r,e){return Zt(r.toString(16).padStart(e*2,"0"))}function ls(r,e){return Xn(r,e).reverse()}function de(r,e,t){let n;if(typeof e=="string")try{n=Zt(e)}catch(o){throw new Error(r+" must be hex string or Uint8Array, cause: "+o)}else if(Ut(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(r+" of length "+t+" expected, got "+s);return n}function yr(r){return Uint8Array.from(r)}const xn=r=>typeof r=="bigint"&&Yn<=r;function Go(r,e,t){return xn(r)&&xn(e)&&xn(t)&&e<=r&&r<t}function Mn(r,e,t,n){if(!Go(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function fs(r){let e;for(e=0;r>Yn;r>>=zn,e+=1);return e}const Ot=r=>(zn<<BigInt(r))-zn;function Zo(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const n=g=>new Uint8Array(g),s=g=>Uint8Array.of(g);let o=n(r),i=n(r),a=0;const c=()=>{o.fill(1),i.fill(0),a=0},f=(...g)=>t(i,o,...g),b=(g=n(0))=>{i=f(s(0),g),o=f(),g.length!==0&&(i=f(s(1),g),o=f())},k=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let g=0;const E=[];for(;g<e;){o=f();const m=o.slice();E.push(m),g+=o.length}return qe(...E)};return(g,E)=>{c(),b(g);let m;for(;!(m=E(k()));)b();return c(),m}}function Nt(r,e,t={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(s,o,i){const a=r[s];if(i&&a===void 0)return;const c=typeof a;if(c!==o||a===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${c}`)}Object.entries(e).forEach(([s,o])=>n(s,o,!1)),Object.entries(t).forEach(([s,o])=>n(s,o,!0))}function Yt(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const o=r(t,...n);return e.set(t,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ve=BigInt(0),Se=BigInt(1),rt=BigInt(2),ds=BigInt(3),hs=BigInt(4),gs=BigInt(5),Yo=BigInt(7),ps=BigInt(8),Xo=BigInt(9),ys=BigInt(16);function pe(r,e){const t=r%e;return t>=ve?t:e+t}function fe(r,e,t){let n=r;for(;e-- >ve;)n*=n,n%=t;return n}function br(r,e){if(r===ve)throw new Error("invert: expected non-zero number");if(e<=ve)throw new Error("invert: expected positive modulus, got "+e);let t=pe(r,e),n=e,s=ve,o=Se;for(;t!==ve;){const a=n/t,c=n%t,f=s-o*a;n=t,t=c,s=o,o=f}if(n!==Se)throw new Error("invert: does not exist");return pe(s,e)}function Jn(r,e,t){if(!r.eql(r.sqr(e),t))throw new Error("Cannot find square root")}function bs(r,e){const t=(r.ORDER+Se)/hs,n=r.pow(e,t);return Jn(r,n,e),n}function Jo(r,e){const t=(r.ORDER-gs)/ps,n=r.mul(e,rt),s=r.pow(n,t),o=r.mul(e,s),i=r.mul(r.mul(o,rt),s),a=r.mul(o,r.sub(i,r.ONE));return Jn(r,a,e),a}function Qo(r){const e=ut(r),t=ms(r),n=t(e,e.neg(e.ONE)),s=t(e,n),o=t(e,e.neg(n)),i=(r+Yo)/ys;return(a,c)=>{let f=a.pow(c,i),b=a.mul(f,n);const k=a.mul(f,s),p=a.mul(f,o),g=a.eql(a.sqr(b),c),E=a.eql(a.sqr(k),c);f=a.cmov(f,b,g),b=a.cmov(p,k,E);const m=a.eql(a.sqr(b),c),I=a.cmov(f,b,m);return Jn(a,I,c),I}}function ms(r){if(r<ds)throw new Error("sqrt is not defined for small field");let e=r-Se,t=0;for(;e%rt===ve;)e/=rt,t++;let n=rt;const s=ut(r);for(;mr(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return bs;let o=s.pow(n,e);const i=(e+Se)/rt;return function(c,f){if(c.is0(f))return f;if(mr(c,f)!==1)throw new Error("Cannot find square root");let b=t,k=c.mul(c.ONE,o),p=c.pow(f,e),g=c.pow(f,i);for(;!c.eql(p,c.ONE);){if(c.is0(p))return c.ZERO;let E=1,m=c.sqr(p);for(;!c.eql(m,c.ONE);)if(E++,m=c.sqr(m),E===b)throw new Error("Cannot find square root");const I=Se<<BigInt(b-E-1),C=c.pow(k,I);b=E,k=c.sqr(C),p=c.mul(p,k),g=c.mul(g,C)}return g}}function ei(r){return r%hs===ds?bs:r%ps===gs?Jo:r%ys===Xo?Qo(r):ms(r)}const ti=(r,e)=>(pe(r,e)&Se)===Se,ni=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ri(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=ni.reduce((n,s)=>(n[s]="function",n),e);return Nt(r,t),r}function si(r,e,t){if(t<ve)throw new Error("invalid exponent, negatives unsupported");if(t===ve)return r.ONE;if(t===Se)return e;let n=r.ONE,s=e;for(;t>ve;)t&Se&&(n=r.mul(n,s)),s=r.sqr(s),t>>=Se;return n}function ws(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),s=e.reduce((i,a,c)=>r.is0(a)?i:(n[c]=i,r.mul(i,a)),r.ONE),o=r.inv(s);return e.reduceRight((i,a,c)=>r.is0(a)?i:(n[c]=r.mul(i,n[c]),r.mul(i,a)),o),n}function mr(r,e){const t=(r.ORDER-Se)/rt,n=r.pow(e,t),s=r.eql(n,r.ONE),o=r.eql(n,r.ZERO),i=r.eql(n,r.neg(r.ONE));if(!s&&!o&&!i)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function Ss(r,e){e!==void 0&&Dn(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function ut(r,e,t=!1,n={}){if(r<=ve)throw new Error("invalid field: expected ORDER > 0, got "+r);let s,o,i=!1,a;if(typeof e=="object"&&e!=null){if(n.sqrt||t)throw new Error("cannot specify opts in two arguments");const p=e;p.BITS&&(s=p.BITS),p.sqrt&&(o=p.sqrt),typeof p.isLE=="boolean"&&(t=p.isLE),typeof p.modFromBytes=="boolean"&&(i=p.modFromBytes),a=p.allowedLengths}else typeof e=="number"&&(s=e),n.sqrt&&(o=n.sqrt);const{nBitLength:c,nByteLength:f}=Ss(r,s);if(f>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let b;const k=Object.freeze({ORDER:r,isLE:t,BITS:c,BYTES:f,MASK:Ot(c),ZERO:ve,ONE:Se,allowedLengths:a,create:p=>pe(p,r),isValid:p=>{if(typeof p!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof p);return ve<=p&&p<r},is0:p=>p===ve,isValidNot0:p=>!k.is0(p)&&k.isValid(p),isOdd:p=>(p&Se)===Se,neg:p=>pe(-p,r),eql:(p,g)=>p===g,sqr:p=>pe(p*p,r),add:(p,g)=>pe(p+g,r),sub:(p,g)=>pe(p-g,r),mul:(p,g)=>pe(p*g,r),pow:(p,g)=>si(k,p,g),div:(p,g)=>pe(p*br(g,r),r),sqrN:p=>p*p,addN:(p,g)=>p+g,subN:(p,g)=>p-g,mulN:(p,g)=>p*g,inv:p=>br(p,r),sqrt:o||(p=>(b||(b=ei(r)),b(k,p))),toBytes:p=>t?ls(p,f):Xn(p,f),fromBytes:(p,g=!0)=>{if(a){if(!a.includes(p.length)||p.length>f)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+p.length);const m=new Uint8Array(f);m.set(p,t?0:m.length-p.length),p=m}if(p.length!==f)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+p.length);let E=t?Tt(p):fn(p);if(i&&(E=pe(E,r)),!g&&!k.isValid(E))throw new Error("invalid field element: outside of range 0..ORDER");return E},invertBatch:p=>ws(k,p),cmov:(p,g,E)=>E?g:p});return Object.freeze(k)}function Es(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function xs(r){const e=Es(r);return e+Math.ceil(e/2)}function oi(r,e,t=!1){const n=r.length,s=Es(e),o=xs(e);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const i=t?Tt(r):fn(r),a=pe(i,e-Se)+Se;return t?ls(a,s):Xn(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bt=BigInt(0),st=BigInt(1);function Xt(r,e){const t=e.negate();return r?t:e}function ot(r,e){const t=ws(r.Fp,e.map(n=>n.Z));return e.map((n,s)=>r.fromAffine(n.toAffine(t[s])))}function ks(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function kn(r,e){ks(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),s=2**r,o=Ot(r),i=BigInt(r);return{windows:t,windowSize:n,mask:o,maxNumber:s,shiftBy:i}}function wr(r,e,t){const{windowSize:n,mask:s,maxNumber:o,shiftBy:i}=t;let a=Number(r&s),c=r>>i;a>n&&(a-=o,c+=st);const f=e*n,b=f+Math.abs(a)-1,k=a===0,p=a<0,g=e%2!==0;return{nextN:c,offset:b,isZero:k,isNeg:p,isNegF:g,offsetF:f}}function ii(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function ci(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const Bn=new WeakMap,Bs=new WeakMap;function _n(r){return Bs.get(r)||1}function Sr(r){if(r!==Bt)throw new Error("invalid wNAF")}class _s{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,n=this.ZERO){let s=e;for(;t>Bt;)t&st&&(n=n.add(s)),s=s.double(),t>>=st;return n}precomputeWindow(e,t){const{windows:n,windowSize:s}=kn(t,this.bits),o=[];let i=e,a=i;for(let c=0;c<n;c++){a=i,o.push(a);for(let f=1;f<s;f++)a=a.add(i),o.push(a);i=a.double()}return o}wNAF(e,t,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const i=kn(e,this.bits);for(let a=0;a<i.windows;a++){const{nextN:c,offset:f,isZero:b,isNeg:k,isNegF:p,offsetF:g}=wr(n,a,i);n=c,b?o=o.add(Xt(p,t[g])):s=s.add(Xt(k,t[f]))}return Sr(n),{p:s,f:o}}wNAFUnsafe(e,t,n,s=this.ZERO){const o=kn(e,this.bits);for(let i=0;i<o.windows&&n!==Bt;i++){const{nextN:a,offset:c,isZero:f,isNeg:b}=wr(n,i,o);if(n=a,!f){const k=t[c];s=s.add(b?k.negate():k)}}return Sr(n),s}getPrecomputes(e,t,n){let s=Bn.get(t);return s||(s=this.precomputeWindow(t,e),e!==1&&(typeof n=="function"&&(s=n(s)),Bn.set(t,s))),s}cached(e,t,n){const s=_n(e);return this.wNAF(s,this.getPrecomputes(s,e,n),t)}unsafe(e,t,n,s){const o=_n(e);return o===1?this._unsafeLadder(e,t,s):this.wNAFUnsafe(o,this.getPrecomputes(o,e,n),t,s)}createCache(e,t){ks(t,this.bits),Bs.set(e,t),Bn.delete(e)}hasCache(e){return _n(e)!==1}}function ai(r,e,t,n){let s=e,o=r.ZERO,i=r.ZERO;for(;t>Bt||n>Bt;)t&st&&(o=o.add(s)),n&st&&(i=i.add(s)),s=s.double(),t>>=st,n>>=st;return{p1:o,p2:i}}function As(r,e,t,n){ii(t,r),ci(n,e);const s=t.length,o=n.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const i=r.ZERO,a=fs(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const f=Ot(c),b=new Array(Number(f)+1).fill(i),k=Math.floor((e.BITS-1)/c)*c;let p=i;for(let g=k;g>=0;g-=c){b.fill(i);for(let m=0;m<o;m++){const I=n[m],C=Number(I>>BigInt(g)&f);b[C]=b[C].add(t[m])}let E=i;for(let m=b.length-1,I=i;m>0;m--)I=I.add(b[m]),E=E.add(I);if(p=p.add(E),g!==0)for(let m=0;m<c;m++)p=p.double()}return p}function Er(r,e,t){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return ri(e),e}else return ut(r,{isLE:t})}function vs(r,e,t={},n){if(n===void 0&&(n=r==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const f=e[c];if(!(typeof f=="bigint"&&f>Bt))throw new Error(`CURVE.${c} must be positive bigint`)}const s=Er(e.p,t.Fp,n),o=Er(e.n,t.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:s,Fn:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xe=BigInt(0),ye=BigInt(1),An=BigInt(2),ui=BigInt(8);function li(r,e,t,n){const s=r.sqr(t),o=r.sqr(n),i=r.add(r.mul(e.a,s),o),a=r.add(r.ONE,r.mul(e.d,r.mul(s,o)));return r.eql(i,a)}function fi(r,e={}){const t=vs("edwards",r,e,e.FpFnLE),{Fp:n,Fn:s}=t;let o=t.CURVE;const{h:i}=o;Nt(e,{},{uvRatio:"function"});const a=An<<BigInt(s.BYTES*8)-ye,c=I=>n.create(I),f=e.uvRatio||((I,C)=>{try{return{isValid:!0,value:n.sqrt(n.div(I,C))}}catch{return{isValid:!1,value:Xe}}});if(!li(n,o,o.Gx,o.Gy))throw new Error("bad curve params: generator point");function b(I,C,q=!1){const U=q?ye:Xe;return Mn("coordinate "+I,C,U,a),C}function k(I){if(!(I instanceof E))throw new Error("ExtendedPoint expected")}const p=Yt((I,C)=>{const{X:q,Y:U,Z:H}=I,j=I.is0();C==null&&(C=j?ui:n.inv(H));const J=c(q*C),se=c(U*C),Y=n.mul(H,C);if(j)return{x:Xe,y:ye};if(Y!==ye)throw new Error("invZ was invalid");return{x:J,y:se}}),g=Yt(I=>{const{a:C,d:q}=o;if(I.is0())throw new Error("bad point: ZERO");const{X:U,Y:H,Z:j,T:J}=I,se=c(U*U),Y=c(H*H),y=c(j*j),w=c(y*y),T=c(se*C),R=c(y*c(T+Y)),B=c(w+c(q*c(se*Y)));if(R!==B)throw new Error("bad point: equation left != right (1)");const x=c(U*H),v=c(j*J);if(x!==v)throw new Error("bad point: equation left != right (2)");return!0});class E{constructor(C,q,U,H){this.X=b("x",C),this.Y=b("y",q),this.Z=b("z",U,!0),this.T=b("t",H),Object.freeze(this)}static CURVE(){return o}static fromAffine(C){if(C instanceof E)throw new Error("extended point not allowed");const{x:q,y:U}=C||{};return b("x",q),b("y",U),new E(q,U,ye,c(q*U))}static fromBytes(C,q=!1){const U=n.BYTES,{a:H,d:j}=o;C=yr(Oe(C,U,"point")),ct(q,"zip215");const J=yr(C),se=C[U-1];J[U-1]=se&-129;const Y=Tt(J),y=q?a:n.ORDER;Mn("point.y",Y,Xe,y);const w=c(Y*Y),T=c(w-ye),R=c(j*w-H);let{isValid:B,value:x}=f(T,R);if(!B)throw new Error("bad point: invalid y coordinate");const v=(x&ye)===ye,P=(se&128)!==0;if(!q&&x===Xe&&P)throw new Error("bad point: x=0 and x_0=1");return P!==v&&(x=c(-x)),E.fromAffine({x,y:Y})}static fromHex(C,q=!1){return E.fromBytes(de("point",C),q)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(C=8,q=!0){return m.createCache(this,C),q||this.multiply(An),this}assertValidity(){g(this)}equals(C){k(C);const{X:q,Y:U,Z:H}=this,{X:j,Y:J,Z:se}=C,Y=c(q*se),y=c(j*H),w=c(U*se),T=c(J*H);return Y===y&&w===T}is0(){return this.equals(E.ZERO)}negate(){return new E(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:C}=o,{X:q,Y:U,Z:H}=this,j=c(q*q),J=c(U*U),se=c(An*c(H*H)),Y=c(C*j),y=q+U,w=c(c(y*y)-j-J),T=Y+J,R=T-se,B=Y-J,x=c(w*R),v=c(T*B),P=c(w*B),K=c(R*T);return new E(x,v,K,P)}add(C){k(C);const{a:q,d:U}=o,{X:H,Y:j,Z:J,T:se}=this,{X:Y,Y:y,Z:w,T}=C,R=c(H*Y),B=c(j*y),x=c(se*U*T),v=c(J*w),P=c((H+j)*(Y+y)-R-B),K=v-x,G=v+x,$=c(B-q*R),W=c(P*K),X=c(G*$),S=c(P*$),u=c(K*G);return new E(W,X,u,S)}subtract(C){return this.add(C.negate())}multiply(C){if(!s.isValidNot0(C))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:q,f:U}=m.cached(this,C,H=>ot(E,H));return ot(E,[q,U])[0]}multiplyUnsafe(C,q=E.ZERO){if(!s.isValid(C))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return C===Xe?E.ZERO:this.is0()||C===ye?this:m.unsafe(this,C,U=>ot(E,U),q)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return m.unsafe(this,o.n).is0()}toAffine(C){return p(this,C)}clearCofactor(){return i===ye?this:this.multiplyUnsafe(i)}toBytes(){const{x:C,y:q}=this.toAffine(),U=n.toBytes(q);return U[U.length-1]|=C&ye?128:0,U}toHex(){return it(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(C){return ot(E,C)}static msm(C,q){return As(E,s,C,q)}_setWindowSize(C){this.precompute(C)}toRawBytes(){return this.toBytes()}}E.BASE=new E(o.Gx,o.Gy,ye,c(o.Gx*o.Gy)),E.ZERO=new E(Xe,ye,ye,Xe),E.Fp=n,E.Fn=s;const m=new _s(E,s.BITS);return E.BASE.precompute(8),E}function di(r,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');Nt(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=t,{BASE:s,Fp:o,Fn:i}=r,a=t.randomBytes||Zn,c=t.adjustScalarBytes||(y=>y),f=t.domain||((y,w,T)=>{if(ct(T,"phflag"),w.length||T)throw new Error("Contexts/pre-hash are not supported");return y});function b(y){return i.create(Tt(y))}function k(y){const w=U.secretKey;y=de("private key",y,w);const T=de("hashed private key",e(y),2*w),R=c(T.slice(0,w)),B=T.slice(w,2*w),x=b(R);return{head:R,prefix:B,scalar:x}}function p(y){const{head:w,prefix:T,scalar:R}=k(y),B=s.multiply(R),x=B.toBytes();return{head:w,prefix:T,scalar:R,point:B,pointBytes:x}}function g(y){return p(y).pointBytes}function E(y=Uint8Array.of(),...w){const T=qe(...w);return b(e(f(T,de("context",y),!!n)))}function m(y,w,T={}){y=de("message",y),n&&(y=n(y));const{prefix:R,scalar:B,pointBytes:x}=p(w),v=E(T.context,R,y),P=s.multiply(v).toBytes(),K=E(T.context,P,x,y),G=i.create(v+K*B);if(!i.isValid(G))throw new Error("sign failed: invalid s");const $=qe(P,i.toBytes(G));return Oe($,U.signature,"result")}const I={zip215:!0};function C(y,w,T,R=I){const{context:B,zip215:x}=R,v=U.signature;y=de("signature",y,v),w=de("message",w),T=de("publicKey",T,U.publicKey),x!==void 0&&ct(x,"zip215"),n&&(w=n(w));const P=v/2,K=y.subarray(0,P),G=Tt(y.subarray(P,v));let $,W,X;try{$=r.fromBytes(T,x),W=r.fromBytes(K,x),X=s.multiplyUnsafe(G)}catch{return!1}if(!x&&$.isSmallOrder())return!1;const S=E(B,W.toBytes(),$.toBytes(),w);return W.add($.multiplyUnsafe(S)).subtract(X).clearCofactor().is0()}const q=o.BYTES,U={secretKey:q,publicKey:q,signature:2*q,seed:q};function H(y=a(U.seed)){return Oe(y,U.seed,"seed")}function j(y){const w=Y.randomSecretKey(y);return{secretKey:w,publicKey:g(w)}}function J(y){return Ut(y)&&y.length===i.BYTES}function se(y,w){try{return!!r.fromBytes(y,w)}catch{return!1}}const Y={getExtendedPublicKey:p,randomSecretKey:H,isValidSecretKey:J,isValidPublicKey:se,toMontgomery(y){const{y:w}=r.fromBytes(y),T=U.publicKey,R=T===32;if(!R&&T!==57)throw new Error("only defined for 25519 and 448");const B=R?o.div(ye+w,ye-w):o.div(w-ye,w+ye);return o.toBytes(B)},toMontgomerySecret(y){const w=U.secretKey;Oe(y,w);const T=e(y.subarray(0,w));return c(T).subarray(0,w)},randomPrivateKey:H,precompute(y=8,w=r.BASE){return w.precompute(y,!1)}};return Object.freeze({keygen:j,getPublicKey:g,sign:m,verify:C,utils:Y,Point:r,lengths:U})}function hi(r){const e={a:r.a,d:r.d,p:r.Fp.ORDER,n:r.n,h:r.h,Gx:r.Gx,Gy:r.Gy},t=r.Fp,n=ut(e.n,r.nBitLength,!0),s={Fp:t,Fn:n,uvRatio:r.uvRatio},o={randomBytes:r.randomBytes,adjustScalarBytes:r.adjustScalarBytes,domain:r.domain,prehash:r.prehash,mapToCurve:r.mapToCurve};return{CURVE:e,curveOpts:s,hash:r.hash,eddsaOpts:o}}function gi(r,e){const t=e.Point;return Object.assign({},e,{ExtendedPoint:t,CURVE:r,nBitLength:t.Fn.BITS,nByteLength:t.Fn.BYTES})}function pi(r){const{CURVE:e,curveOpts:t,hash:n,eddsaOpts:s}=hi(r),o=fi(e,t),i=di(o,n,s);return gi(r,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yi=BigInt(1),xr=BigInt(2);BigInt(3);const bi=BigInt(5),mi=BigInt(8),Qn=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Is={p:Qn,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:mi,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function wi(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),o=Qn,a=r*r%o*r%o,c=fe(a,xr,o)*a%o,f=fe(c,yi,o)*r%o,b=fe(f,bi,o)*f%o,k=fe(b,e,o)*b%o,p=fe(k,t,o)*k%o,g=fe(p,n,o)*p%o,E=fe(g,s,o)*g%o,m=fe(E,s,o)*g%o,I=fe(m,e,o)*b%o;return{pow_p_5_8:fe(I,xr,o)*r%o,b2:a}}function Si(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const kr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Ei(r,e){const t=Qn,n=pe(e*e*e,t),s=pe(n*n*e,t),o=wi(r*s).pow_p_5_8;let i=pe(r*n*o,t);const a=pe(e*i*i,t),c=i,f=pe(i*kr,t),b=a===r,k=a===pe(-r,t),p=a===pe(-r*kr,t);return b&&(i=c),(k||p)&&(i=f),ti(i,t)&&(i=pe(-i,t)),{isValid:b||k,value:i}}const xi=ut(Is.p,{isLE:!0}),ki={...Is,Fp:xi,hash:Vo,adjustScalarBytes:Si,uvRatio:Ei},Pt=pi(ki);var Bi=Xr();const Br=Vn(Bi);var vn,_r;function _i(){if(_r)return vn;_r=1;var r=co().Buffer;function e(t){if(t.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),s=0;s<n.length;s++)n[s]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),a=i.charCodeAt(0);if(n[a]!==255)throw new TypeError(i+" is ambiguous");n[a]=o}var c=t.length,f=t.charAt(0),b=Math.log(c)/Math.log(256),k=Math.log(256)/Math.log(c);function p(m){if((Array.isArray(m)||m instanceof Uint8Array)&&(m=r.from(m)),!r.isBuffer(m))throw new TypeError("Expected Buffer");if(m.length===0)return"";for(var I=0,C=0,q=0,U=m.length;q!==U&&m[q]===0;)q++,I++;for(var H=(U-q)*k+1>>>0,j=new Uint8Array(H);q!==U;){for(var J=m[q],se=0,Y=H-1;(J!==0||se<C)&&Y!==-1;Y--,se++)J+=256*j[Y]>>>0,j[Y]=J%c>>>0,J=J/c>>>0;if(J!==0)throw new Error("Non-zero carry");C=se,q++}for(var y=H-C;y!==H&&j[y]===0;)y++;for(var w=f.repeat(I);y<H;++y)w+=t.charAt(j[y]);return w}function g(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return r.alloc(0);for(var I=0,C=0,q=0;m[I]===f;)C++,I++;for(var U=(m.length-I)*b+1>>>0,H=new Uint8Array(U);I<m.length;){var j=m.charCodeAt(I);if(j>255)return;var J=n[j];if(J===255)return;for(var se=0,Y=U-1;(J!==0||se<q)&&Y!==-1;Y--,se++)J+=c*H[Y]>>>0,H[Y]=J%256>>>0,J=J/256>>>0;if(J!==0)throw new Error("Non-zero carry");q=se,I++}for(var y=U-q;y!==U&&H[y]===0;)y++;var w=r.allocUnsafe(C+(U-y));w.fill(0,0,C);for(var T=C;y!==U;)w[T++]=H[y++];return w}function E(m){var I=g(m);if(I)return I;throw new Error("Non-base"+c+" character")}return{encode:p,decodeUnsafe:g,decode:E}}return vn=e,vn}var In,Ar;function Rs(){if(Ar)return In;Ar=1;var r=_i(),e="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return In=r(e),In}var Ai=Rs();const we=Vn(Ai),vr=as;var ie={};function He(r,e,t){return e<=r&&r<=t}function dn(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function vi(r){for(var e=String(r),t=e.length,n=0,s=[];n<t;){var o=e.charCodeAt(n);if(o<55296||o>57343)s.push(o);else if(56320<=o&&o<=57343)s.push(65533);else if(55296<=o&&o<=56319)if(n===t-1)s.push(65533);else{var i=r.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=o&1023,c=i&1023;s.push(65536+(a<<10)+c),n+=1}else s.push(65533)}n+=1}return s}function Ii(r){for(var e="",t=0;t<r.length;++t){var n=r[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var Jt=-1;function er(r){this.tokens=[].slice.call(r)}er.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():Jt},prepend:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var e=r;e.length;)this.tokens.push(e.shift());else this.tokens.push(r)}};var _t=-1;function Rn(r,e){if(r)throw TypeError("Decoder error");return e||65533}var Qt="utf-8";function en(r,e){if(!(this instanceof en))return new en(r,e);if(r=r!==void 0?String(r).toLowerCase():Qt,r!==Qt)throw new Error("Encoding not supported. Only utf-8 is supported");e=dn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}en.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=dn(t),this._streaming||(this._decoder=new Ri({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var s=new er(n),o=[],i;!s.endOfStream()&&(i=this._decoder.handler(s,s.read()),i!==_t);)i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i));if(!this._streaming){do{if(i=this._decoder.handler(s,s.read()),i===_t)break;i!==null&&(Array.isArray(i)?o.push.apply(o,i):o.push(i))}while(!s.endOfStream());this._decoder=null}return o.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(o[0]===65279?(this._BOMseen=!0,o.shift()):this._BOMseen=!0),Ii(o)}};function tn(r,e){if(!(this instanceof tn))return new tn(r,e);if(r=r!==void 0?String(r).toLowerCase():Qt,r!==Qt)throw new Error("Encoding not supported. Only utf-8 is supported");e=dn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}tn.prototype={encode:function(e,t){e=e?String(e):"",t=dn(t),this._streaming||(this._encoder=new Ci(this._options)),this._streaming=!!t.stream;for(var n=[],s=new er(vi(e)),o;!s.endOfStream()&&(o=this._encoder.handler(s,s.read()),o!==_t);)Array.isArray(o)?n.push.apply(n,o):n.push(o);if(!this._streaming){for(;o=this._encoder.handler(s,s.read()),o!==_t;)Array.isArray(o)?n.push.apply(n,o):n.push(o);this._encoder=null}return new Uint8Array(n)}};function Ri(r){var e=r.fatal,t=0,n=0,s=0,o=128,i=191;this.handler=function(a,c){if(c===Jt&&s!==0)return s=0,Rn(e);if(c===Jt)return _t;if(s===0){if(He(c,0,127))return c;if(He(c,194,223))s=1,t=c-192;else if(He(c,224,239))c===224&&(o=160),c===237&&(i=159),s=2,t=c-224;else if(He(c,240,244))c===240&&(o=144),c===244&&(i=143),s=3,t=c-240;else return Rn(e);return t=t<<6*s,null}if(!He(c,o,i))return t=s=n=0,o=128,i=191,a.prepend(c),Rn(e);if(o=128,i=191,n+=1,t+=c-128<<6*(s-n),n!==s)return null;var f=t;return t=s=n=0,f}}function Ci(r){r.fatal,this.handler=function(e,t){if(t===Jt)return _t;if(He(t,0,127))return t;var n,s;He(t,128,2047)?(n=1,s=192):He(t,2048,65535)?(n=2,s=224):He(t,65536,1114111)&&(n=3,s=240);for(var o=[(t>>6*n)+s];n>0;){var i=t>>6*(n-1);o.push(128|i&63),n-=1}return o}}const Ti=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:en,TextEncoder:tn},Symbol.toStringTag,{value:"Module"})),Li=Zr(Ti);var Ir;function Ui(){if(Ir)return ie;Ir=1;var r=ie&&ie.__createBinding||(Object.create?function(y,w,T,R){R===void 0&&(R=T),Object.defineProperty(y,R,{enumerable:!0,get:function(){return w[T]}})}:function(y,w,T,R){R===void 0&&(R=T),y[R]=w[T]}),e=ie&&ie.__setModuleDefault||(Object.create?function(y,w){Object.defineProperty(y,"default",{enumerable:!0,value:w})}:function(y,w){y.default=w}),t=ie&&ie.__decorate||function(y,w,T,R){var B=arguments.length,x=B<3?w:R===null?R=Object.getOwnPropertyDescriptor(w,T):R,v;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")x=Reflect.decorate(y,w,T,R);else for(var P=y.length-1;P>=0;P--)(v=y[P])&&(x=(B<3?v(x):B>3?v(w,T,x):v(w,T))||x);return B>3&&x&&Object.defineProperty(w,T,x),x},n=ie&&ie.__importStar||function(y){if(y&&y.__esModule)return y;var w={};if(y!=null)for(var T in y)T!=="default"&&Object.hasOwnProperty.call(y,T)&&r(w,y,T);return e(w,y),w},s=ie&&ie.__importDefault||function(y){return y&&y.__esModule?y:{default:y}};Object.defineProperty(ie,"__esModule",{value:!0}),ie.deserializeUnchecked=ie.deserialize=ie.serialize=ie.BinaryReader=ie.BinaryWriter=ie.BorshError=ie.baseDecode=ie.baseEncode=void 0;const o=s(Xr()),i=s(Rs()),a=n(Li),c=typeof TextDecoder!="function"?a.TextDecoder:TextDecoder,f=new c("utf-8",{fatal:!0});function b(y){return typeof y=="string"&&(y=Buffer.from(y,"utf8")),i.default.encode(Buffer.from(y))}ie.baseEncode=b;function k(y){return Buffer.from(i.default.decode(y))}ie.baseDecode=k;const p=1024;class g extends Error{constructor(w){super(w),this.fieldPath=[],this.originalMessage=w}addToFieldPath(w){this.fieldPath.splice(0,0,w),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}ie.BorshError=g;class E{constructor(){this.buf=Buffer.alloc(p),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(p)]))}writeU8(w){this.maybeResize(),this.buf.writeUInt8(w,this.length),this.length+=1}writeU16(w){this.maybeResize(),this.buf.writeUInt16LE(w,this.length),this.length+=2}writeU32(w){this.maybeResize(),this.buf.writeUInt32LE(w,this.length),this.length+=4}writeU64(w){this.maybeResize(),this.writeBuffer(Buffer.from(new o.default(w).toArray("le",8)))}writeU128(w){this.maybeResize(),this.writeBuffer(Buffer.from(new o.default(w).toArray("le",16)))}writeU256(w){this.maybeResize(),this.writeBuffer(Buffer.from(new o.default(w).toArray("le",32)))}writeU512(w){this.maybeResize(),this.writeBuffer(Buffer.from(new o.default(w).toArray("le",64)))}writeBuffer(w){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),w,Buffer.alloc(p)]),this.length+=w.length}writeString(w){this.maybeResize();const T=Buffer.from(w,"utf8");this.writeU32(T.length),this.writeBuffer(T)}writeFixedArray(w){this.writeBuffer(Buffer.from(w))}writeArray(w,T){this.maybeResize(),this.writeU32(w.length);for(const R of w)this.maybeResize(),T(R)}toArray(){return this.buf.subarray(0,this.length)}}ie.BinaryWriter=E;function m(y,w,T){const R=T.value;T.value=function(...B){try{return R.apply(this,B)}catch(x){if(x instanceof RangeError){const v=x.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(v)>=0)throw new g("Reached the end of buffer when deserializing")}throw x}}}class I{constructor(w){this.buf=w,this.offset=0}readU8(){const w=this.buf.readUInt8(this.offset);return this.offset+=1,w}readU16(){const w=this.buf.readUInt16LE(this.offset);return this.offset+=2,w}readU32(){const w=this.buf.readUInt32LE(this.offset);return this.offset+=4,w}readU64(){const w=this.readBuffer(8);return new o.default(w,"le")}readU128(){const w=this.readBuffer(16);return new o.default(w,"le")}readU256(){const w=this.readBuffer(32);return new o.default(w,"le")}readU512(){const w=this.readBuffer(64);return new o.default(w,"le")}readBuffer(w){if(this.offset+w>this.buf.length)throw new g(`Expected buffer length ${w} isn't within bounds`);const T=this.buf.slice(this.offset,this.offset+w);return this.offset+=w,T}readString(){const w=this.readU32(),T=this.readBuffer(w);try{return f.decode(T)}catch(R){throw new g(`Error decoding UTF-8 string: ${R}`)}}readFixedArray(w){return new Uint8Array(this.readBuffer(w))}readArray(w){const T=this.readU32(),R=Array();for(let B=0;B<T;++B)R.push(w());return R}}t([m],I.prototype,"readU8",null),t([m],I.prototype,"readU16",null),t([m],I.prototype,"readU32",null),t([m],I.prototype,"readU64",null),t([m],I.prototype,"readU128",null),t([m],I.prototype,"readU256",null),t([m],I.prototype,"readU512",null),t([m],I.prototype,"readString",null),t([m],I.prototype,"readFixedArray",null),t([m],I.prototype,"readArray",null),ie.BinaryReader=I;function C(y){return y.charAt(0).toUpperCase()+y.slice(1)}function q(y,w,T,R,B){try{if(typeof R=="string")B[`write${C(R)}`](T);else if(R instanceof Array)if(typeof R[0]=="number"){if(T.length!==R[0])throw new g(`Expecting byte array of length ${R[0]}, but got ${T.length} bytes`);B.writeFixedArray(T)}else if(R.length===2&&typeof R[1]=="number"){if(T.length!==R[1])throw new g(`Expecting byte array of length ${R[1]}, but got ${T.length} bytes`);for(let x=0;x<R[1];x++)q(y,null,T[x],R[0],B)}else B.writeArray(T,x=>{q(y,w,x,R[0],B)});else if(R.kind!==void 0)switch(R.kind){case"option":{T==null?B.writeU8(0):(B.writeU8(1),q(y,w,T,R.type,B));break}case"map":{B.writeU32(T.size),T.forEach((x,v)=>{q(y,w,v,R.key,B),q(y,w,x,R.value,B)});break}default:throw new g(`FieldType ${R} unrecognized`)}else U(y,T,B)}catch(x){throw x instanceof g&&x.addToFieldPath(w),x}}function U(y,w,T){if(typeof w.borshSerialize=="function"){w.borshSerialize(T);return}const R=y.get(w.constructor);if(!R)throw new g(`Class ${w.constructor.name} is missing in schema`);if(R.kind==="struct")R.fields.map(([B,x])=>{q(y,B,w[B],x,T)});else if(R.kind==="enum"){const B=w[R.field];for(let x=0;x<R.values.length;++x){const[v,P]=R.values[x];if(v===B){T.writeU8(x),q(y,v,w[v],P,T);break}}}else throw new g(`Unexpected schema kind: ${R.kind} for ${w.constructor.name}`)}function H(y,w,T=E){const R=new T;return U(y,w,R),R.toArray()}ie.serialize=H;function j(y,w,T,R){try{if(typeof T=="string")return R[`read${C(T)}`]();if(T instanceof Array){if(typeof T[0]=="number")return R.readFixedArray(T[0]);if(typeof T[1]=="number"){const B=[];for(let x=0;x<T[1];x++)B.push(j(y,null,T[0],R));return B}else return R.readArray(()=>j(y,w,T[0],R))}if(T.kind==="option")return R.readU8()?j(y,w,T.type,R):void 0;if(T.kind==="map"){let B=new Map;const x=R.readU32();for(let v=0;v<x;v++){const P=j(y,w,T.key,R),K=j(y,w,T.value,R);B.set(P,K)}return B}return J(y,T,R)}catch(B){throw B instanceof g&&B.addToFieldPath(w),B}}function J(y,w,T){if(typeof w.borshDeserialize=="function")return w.borshDeserialize(T);const R=y.get(w);if(!R)throw new g(`Class ${w.name} is missing in schema`);if(R.kind==="struct"){const B={};for(const[x,v]of y.get(w).fields)B[x]=j(y,x,v,T);return new w(B)}if(R.kind==="enum"){const B=T.readU8();if(B>=R.values.length)throw new g(`Enum index: ${B} is out of range`);const[x,v]=R.values[B],P=j(y,x,v,T);return new w({[x]:P})}throw new g(`Unexpected schema kind: ${R.kind} for ${w.constructor.name}`)}function se(y,w,T,R=I){const B=new R(T),x=J(y,w,B);if(B.offset<T.length)throw new g(`Unexpected ${T.length-B.offset} bytes after deserialized data`);return x}ie.deserialize=se;function Y(y,w,T,R=I){const B=new R(T);return J(y,w,B)}return ie.deserializeUnchecked=Y,ie}var Cn=Ui(),A={},Rr;function Oi(){if(Rr)return A;Rr=1,Object.defineProperty(A,"__esModule",{value:!0}),A.s16=A.s8=A.nu64be=A.u48be=A.u40be=A.u32be=A.u24be=A.u16be=A.nu64=A.u48=A.u40=A.u32=A.u24=A.u16=A.u8=A.offset=A.greedy=A.Constant=A.UTF8=A.CString=A.Blob=A.Boolean=A.BitField=A.BitStructure=A.VariantLayout=A.Union=A.UnionLayoutDiscriminator=A.UnionDiscriminator=A.Structure=A.Sequence=A.DoubleBE=A.Double=A.FloatBE=A.Float=A.NearInt64BE=A.NearInt64=A.NearUInt64BE=A.NearUInt64=A.IntBE=A.Int=A.UIntBE=A.UInt=A.OffsetLayout=A.GreedyCount=A.ExternalLayout=A.bindConstructorLayout=A.nameWithProperty=A.Layout=A.uint8ArrayToBuffer=A.checkUint8Array=void 0,A.constant=A.utf8=A.cstr=A.blob=A.unionLayoutDiscriminator=A.union=A.seq=A.bits=A.struct=A.f64be=A.f64=A.f32be=A.f32=A.ns64be=A.s48be=A.s40be=A.s32be=A.s24be=A.s16be=A.ns64=A.s48=A.s40=A.s32=A.s24=void 0;const r=io();function e(S){if(!(S instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}A.checkUint8Array=e;function t(S){return e(S),r.Buffer.from(S.buffer,S.byteOffset,S.length)}A.uint8ArrayToBuffer=t;let n=class{constructor(u,l){if(!Number.isInteger(u))throw new TypeError("span must be an integer");this.span=u,this.property=l}makeDestinationObject(){return{}}getSpan(u,l){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(u){const l=Object.create(this.constructor.prototype);return Object.assign(l,this),l.property=u,l}fromArray(u){}};A.Layout=n;function s(S,u){return u.property?S+"["+u.property+"]":S}A.nameWithProperty=s;function o(S,u){if(typeof S!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(S,"layout_"))throw new Error("Class is already bound to a layout");if(!(u&&u instanceof n))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(u,"boundConstructor_"))throw new Error("layout is already bound to a constructor");S.layout_=u,u.boundConstructor_=S,u.makeDestinationObject=()=>new S,Object.defineProperty(S.prototype,"encode",{value(l,d){return u.encode(this,l,d)},writable:!0}),Object.defineProperty(S,"decode",{value(l,d){return u.decode(l,d)},writable:!0})}A.bindConstructorLayout=o;class i extends n{isCount(){throw new Error("ExternalLayout is abstract")}}A.ExternalLayout=i;class a extends i{constructor(u=1,l){if(!Number.isInteger(u)||0>=u)throw new TypeError("elementSpan must be a (positive) integer");super(-1,l),this.elementSpan=u}isCount(){return!0}decode(u,l=0){e(u);const d=u.length-l;return Math.floor(d/this.elementSpan)}encode(u,l,d){return 0}}A.GreedyCount=a;class c extends i{constructor(u,l=0,d){if(!(u instanceof n))throw new TypeError("layout must be a Layout");if(!Number.isInteger(l))throw new TypeError("offset must be integer or undefined");super(u.span,d||u.property),this.layout=u,this.offset=l}isCount(){return this.layout instanceof f||this.layout instanceof b}decode(u,l=0){return this.layout.decode(u,l+this.offset)}encode(u,l,d=0){return this.layout.encode(u,l,d+this.offset)}}A.OffsetLayout=c;class f extends n{constructor(u,l){if(super(u,l),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,l=0){return t(u).readUIntLE(l,this.span)}encode(u,l,d=0){return t(l).writeUIntLE(u,d,this.span),this.span}}A.UInt=f;class b extends n{constructor(u,l){if(super(u,l),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,l=0){return t(u).readUIntBE(l,this.span)}encode(u,l,d=0){return t(l).writeUIntBE(u,d,this.span),this.span}}A.UIntBE=b;class k extends n{constructor(u,l){if(super(u,l),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,l=0){return t(u).readIntLE(l,this.span)}encode(u,l,d=0){return t(l).writeIntLE(u,d,this.span),this.span}}A.Int=k;class p extends n{constructor(u,l){if(super(u,l),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,l=0){return t(u).readIntBE(l,this.span)}encode(u,l,d=0){return t(l).writeIntBE(u,d,this.span),this.span}}A.IntBE=p;const g=Math.pow(2,32);function E(S){const u=Math.floor(S/g),l=S-u*g;return{hi32:u,lo32:l}}function m(S,u){return S*g+u}class I extends n{constructor(u){super(8,u)}decode(u,l=0){const d=t(u),L=d.readUInt32LE(l),O=d.readUInt32LE(l+4);return m(O,L)}encode(u,l,d=0){const L=E(u),O=t(l);return O.writeUInt32LE(L.lo32,d),O.writeUInt32LE(L.hi32,d+4),8}}A.NearUInt64=I;class C extends n{constructor(u){super(8,u)}decode(u,l=0){const d=t(u),L=d.readUInt32BE(l),O=d.readUInt32BE(l+4);return m(L,O)}encode(u,l,d=0){const L=E(u),O=t(l);return O.writeUInt32BE(L.hi32,d),O.writeUInt32BE(L.lo32,d+4),8}}A.NearUInt64BE=C;class q extends n{constructor(u){super(8,u)}decode(u,l=0){const d=t(u),L=d.readUInt32LE(l),O=d.readInt32LE(l+4);return m(O,L)}encode(u,l,d=0){const L=E(u),O=t(l);return O.writeUInt32LE(L.lo32,d),O.writeInt32LE(L.hi32,d+4),8}}A.NearInt64=q;class U extends n{constructor(u){super(8,u)}decode(u,l=0){const d=t(u),L=d.readInt32BE(l),O=d.readUInt32BE(l+4);return m(L,O)}encode(u,l,d=0){const L=E(u),O=t(l);return O.writeInt32BE(L.hi32,d),O.writeUInt32BE(L.lo32,d+4),8}}A.NearInt64BE=U;class H extends n{constructor(u){super(4,u)}decode(u,l=0){return t(u).readFloatLE(l)}encode(u,l,d=0){return t(l).writeFloatLE(u,d),4}}A.Float=H;class j extends n{constructor(u){super(4,u)}decode(u,l=0){return t(u).readFloatBE(l)}encode(u,l,d=0){return t(l).writeFloatBE(u,d),4}}A.FloatBE=j;class J extends n{constructor(u){super(8,u)}decode(u,l=0){return t(u).readDoubleLE(l)}encode(u,l,d=0){return t(l).writeDoubleLE(u,d),8}}A.Double=J;class se extends n{constructor(u){super(8,u)}decode(u,l=0){return t(u).readDoubleBE(l)}encode(u,l,d=0){return t(l).writeDoubleBE(u,d),8}}A.DoubleBE=se;class Y extends n{constructor(u,l,d){if(!(u instanceof n))throw new TypeError("elementLayout must be a Layout");if(!(l instanceof i&&l.isCount()||Number.isInteger(l)&&0<=l))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let L=-1;!(l instanceof i)&&0<u.span&&(L=l*u.span),super(L,d),this.elementLayout=u,this.count=l}getSpan(u,l=0){if(0<=this.span)return this.span;let d=0,L=this.count;if(L instanceof i&&(L=L.decode(u,l)),0<this.elementLayout.span)d=L*this.elementLayout.span;else{let O=0;for(;O<L;)d+=this.elementLayout.getSpan(u,l+d),++O}return d}decode(u,l=0){const d=[];let L=0,O=this.count;for(O instanceof i&&(O=O.decode(u,l));L<O;)d.push(this.elementLayout.decode(u,l)),l+=this.elementLayout.getSpan(u,l),L+=1;return d}encode(u,l,d=0){const L=this.elementLayout,O=u.reduce((ee,te)=>ee+L.encode(te,l,d+ee),0);return this.count instanceof i&&this.count.encode(u.length,l,d),O}}A.Sequence=Y;class y extends n{constructor(u,l,d){if(!(Array.isArray(u)&&u.reduce((O,ee)=>O&&ee instanceof n,!0)))throw new TypeError("fields must be array of Layout instances");typeof l=="boolean"&&d===void 0&&(d=l,l=void 0);for(const O of u)if(0>O.span&&O.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let L=-1;try{L=u.reduce((O,ee)=>O+ee.getSpan(),0)}catch{}super(L,l),this.fields=u,this.decodePrefixes=!!d}getSpan(u,l=0){if(0<=this.span)return this.span;let d=0;try{d=this.fields.reduce((L,O)=>{const ee=O.getSpan(u,l);return l+=ee,L+ee},0)}catch{throw new RangeError("indeterminate span")}return d}decode(u,l=0){e(u);const d=this.makeDestinationObject();for(const L of this.fields)if(L.property!==void 0&&(d[L.property]=L.decode(u,l)),l+=L.getSpan(u,l),this.decodePrefixes&&u.length===l)break;return d}encode(u,l,d=0){const L=d;let O=0,ee=0;for(const te of this.fields){let ae=te.span;if(ee=0<ae?ae:0,te.property!==void 0){const nt=u[te.property];nt!==void 0&&(ee=te.encode(nt,l,d),0>ae&&(ae=te.getSpan(l,d)))}O=d,d+=ae}return O+ee-L}fromArray(u){const l=this.makeDestinationObject();for(const d of this.fields)d.property!==void 0&&0<u.length&&(l[d.property]=u.shift());return l}layoutFor(u){if(typeof u!="string")throw new TypeError("property must be string");for(const l of this.fields)if(l.property===u)return l}offsetOf(u){if(typeof u!="string")throw new TypeError("property must be string");let l=0;for(const d of this.fields){if(d.property===u)return l;0>d.span?l=-1:0<=l&&(l+=d.span)}}}A.Structure=y;class w{constructor(u){this.property=u}decode(u,l){throw new Error("UnionDiscriminator is abstract")}encode(u,l,d){throw new Error("UnionDiscriminator is abstract")}}A.UnionDiscriminator=w;class T extends w{constructor(u,l){if(!(u instanceof i&&u.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(l||u.property||"variant"),this.layout=u}decode(u,l){return this.layout.decode(u,l)}encode(u,l,d){return this.layout.encode(u,l,d)}}A.UnionLayoutDiscriminator=T;class R extends n{constructor(u,l,d){let L;if(u instanceof f||u instanceof b)L=new T(new c(u));else if(u instanceof i&&u.isCount())L=new T(u);else if(u instanceof w)L=u;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(l===void 0&&(l=null),!(l===null||l instanceof n))throw new TypeError("defaultLayout must be null or a Layout");if(l!==null){if(0>l.span)throw new Error("defaultLayout must have constant span");l.property===void 0&&(l=l.replicate("content"))}let O=-1;l&&(O=l.span,0<=O&&(u instanceof f||u instanceof b)&&(O+=L.layout.span)),super(O,d),this.discriminator=L,this.usesPrefixDiscriminator=u instanceof f||u instanceof b,this.defaultLayout=l,this.registry={};let ee=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(te){return ee(te)},this.configGetSourceVariant=function(te){ee=te.bind(this)}}getSpan(u,l=0){if(0<=this.span)return this.span;const d=this.getVariant(u,l);if(!d)throw new Error("unable to determine span for unrecognized variant");return d.getSpan(u,l)}defaultGetSourceVariant(u){if(Object.prototype.hasOwnProperty.call(u,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(u,this.defaultLayout.property))return;const l=this.registry[u[this.discriminator.property]];if(l&&(!l.layout||l.property&&Object.prototype.hasOwnProperty.call(u,l.property)))return l}else for(const l in this.registry){const d=this.registry[l];if(d.property&&Object.prototype.hasOwnProperty.call(u,d.property))return d}throw new Error("unable to infer src variant")}decode(u,l=0){let d;const L=this.discriminator,O=L.decode(u,l),ee=this.registry[O];if(ee===void 0){const te=this.defaultLayout;let ae=0;this.usesPrefixDiscriminator&&(ae=L.layout.span),d=this.makeDestinationObject(),d[L.property]=O,d[te.property]=te.decode(u,l+ae)}else d=ee.decode(u,l);return d}encode(u,l,d=0){const L=this.getSourceVariant(u);if(L===void 0){const O=this.discriminator,ee=this.defaultLayout;let te=0;return this.usesPrefixDiscriminator&&(te=O.layout.span),O.encode(u[O.property],l,d),te+ee.encode(u[ee.property],l,d+te)}return L.encode(u,l,d)}addVariant(u,l,d){const L=new B(this,u,l,d);return this.registry[u]=L,L}getVariant(u,l=0){let d;return u instanceof Uint8Array?d=this.discriminator.decode(u,l):d=u,this.registry[d]}}A.Union=R;class B extends n{constructor(u,l,d,L){if(!(u instanceof R))throw new TypeError("union must be a Union");if(!Number.isInteger(l)||0>l)throw new TypeError("variant must be a (non-negative) integer");if(typeof d=="string"&&L===void 0&&(L=d,d=null),d){if(!(d instanceof n))throw new TypeError("layout must be a Layout");if(u.defaultLayout!==null&&0<=d.span&&d.span>u.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof L!="string")throw new TypeError("variant must have a String property")}let O=u.span;0>u.span&&(O=d?d.span:0,0<=O&&u.usesPrefixDiscriminator&&(O+=u.discriminator.layout.span)),super(O,L),this.union=u,this.variant=l,this.layout=d||null}getSpan(u,l=0){if(0<=this.span)return this.span;let d=0;this.union.usesPrefixDiscriminator&&(d=this.union.discriminator.layout.span);let L=0;return this.layout&&(L=this.layout.getSpan(u,l+d)),d+L}decode(u,l=0){const d=this.makeDestinationObject();if(this!==this.union.getVariant(u,l))throw new Error("variant mismatch");let L=0;return this.union.usesPrefixDiscriminator&&(L=this.union.discriminator.layout.span),this.layout?d[this.property]=this.layout.decode(u,l+L):this.property?d[this.property]=!0:this.union.usesPrefixDiscriminator&&(d[this.union.discriminator.property]=this.variant),d}encode(u,l,d=0){let L=0;if(this.union.usesPrefixDiscriminator&&(L=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(u,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,l,d);let O=L;if(this.layout&&(this.layout.encode(u[this.property],l,d+L),O+=this.layout.getSpan(l,d+L),0<=this.union.span&&O>this.union.span))throw new Error("encoded variant overruns containing union");return O}fromArray(u){if(this.layout)return this.layout.fromArray(u)}}A.VariantLayout=B;function x(S){return 0>S&&(S+=4294967296),S}class v extends n{constructor(u,l,d){if(!(u instanceof f||u instanceof b))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof l=="string"&&d===void 0&&(d=l,l=!1),4<u.span)throw new RangeError("word cannot exceed 32 bits");super(u.span,d),this.word=u,this.msb=!!l,this.fields=[];let L=0;this._packedSetValue=function(O){return L=x(O),this},this._packedGetValue=function(){return L}}decode(u,l=0){const d=this.makeDestinationObject(),L=this.word.decode(u,l);this._packedSetValue(L);for(const O of this.fields)O.property!==void 0&&(d[O.property]=O.decode(u));return d}encode(u,l,d=0){const L=this.word.decode(l,d);this._packedSetValue(L);for(const O of this.fields)if(O.property!==void 0){const ee=u[O.property];ee!==void 0&&O.encode(ee)}return this.word.encode(this._packedGetValue(),l,d)}addField(u,l){const d=new P(this,u,l);return this.fields.push(d),d}addBoolean(u){const l=new K(this,u);return this.fields.push(l),l}fieldFor(u){if(typeof u!="string")throw new TypeError("property must be string");for(const l of this.fields)if(l.property===u)return l}}A.BitStructure=v;class P{constructor(u,l,d){if(!(u instanceof v))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(l)||0>=l)throw new TypeError("bits must be positive integer");const L=8*u.span,O=u.fields.reduce((ee,te)=>ee+te.bits,0);if(l+O>L)throw new Error("bits too long for span remainder ("+(L-O)+" of "+L+" remain)");this.container=u,this.bits=l,this.valueMask=(1<<l)-1,l===32&&(this.valueMask=4294967295),this.start=O,this.container.msb&&(this.start=L-O-l),this.wordMask=x(this.valueMask<<this.start),this.property=d}decode(u,l){const d=this.container._packedGetValue();return x(d&this.wordMask)>>>this.start}encode(u){if(typeof u!="number"||!Number.isInteger(u)||u!==x(u&this.valueMask))throw new TypeError(s("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const l=this.container._packedGetValue(),d=x(u<<this.start);this.container._packedSetValue(x(l&~this.wordMask)|d)}}A.BitField=P;class K extends P{constructor(u,l){super(u,1,l)}decode(u,l){return!!super.decode(u,l)}encode(u){typeof u=="boolean"&&(u=+u),super.encode(u)}}A.Boolean=K;class G extends n{constructor(u,l){if(!(u instanceof i&&u.isCount()||Number.isInteger(u)&&0<=u))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let d=-1;u instanceof i||(d=u),super(d,l),this.length=u}getSpan(u,l){let d=this.span;return 0>d&&(d=this.length.decode(u,l)),d}decode(u,l=0){let d=this.span;return 0>d&&(d=this.length.decode(u,l)),t(u).slice(l,l+d)}encode(u,l,d){let L=this.length;if(this.length instanceof i&&(L=u.length),!(u instanceof Uint8Array&&L===u.length))throw new TypeError(s("Blob.encode",this)+" requires (length "+L+") Uint8Array as src");if(d+L>l.length)throw new RangeError("encoding overruns Uint8Array");const O=t(u);return t(l).write(O.toString("hex"),d,L,"hex"),this.length instanceof i&&this.length.encode(L,l,d),L}}A.Blob=G;class $ extends n{constructor(u){super(-1,u)}getSpan(u,l=0){e(u);let d=l;for(;d<u.length&&u[d]!==0;)d+=1;return 1+d-l}decode(u,l=0){const d=this.getSpan(u,l);return t(u).slice(l,l+d-1).toString("utf-8")}encode(u,l,d=0){typeof u!="string"&&(u=String(u));const L=r.Buffer.from(u,"utf8"),O=L.length;if(d+O>l.length)throw new RangeError("encoding overruns Buffer");const ee=t(l);return L.copy(ee,d),ee[d+O]=0,O+1}}A.CString=$;class W extends n{constructor(u,l){if(typeof u=="string"&&l===void 0&&(l=u,u=void 0),u===void 0)u=-1;else if(!Number.isInteger(u))throw new TypeError("maxSpan must be an integer");super(-1,l),this.maxSpan=u}getSpan(u,l=0){return e(u),u.length-l}decode(u,l=0){const d=this.getSpan(u,l);if(0<=this.maxSpan&&this.maxSpan<d)throw new RangeError("text length exceeds maxSpan");return t(u).slice(l,l+d).toString("utf-8")}encode(u,l,d=0){typeof u!="string"&&(u=String(u));const L=r.Buffer.from(u,"utf8"),O=L.length;if(0<=this.maxSpan&&this.maxSpan<O)throw new RangeError("text length exceeds maxSpan");if(d+O>l.length)throw new RangeError("encoding overruns Buffer");return L.copy(t(l),d),O}}A.UTF8=W;class X extends n{constructor(u,l){super(0,l),this.value=u}decode(u,l){return this.value}encode(u,l,d){return 0}}return A.Constant=X,A.greedy=(S,u)=>new a(S,u),A.offset=(S,u,l)=>new c(S,u,l),A.u8=S=>new f(1,S),A.u16=S=>new f(2,S),A.u24=S=>new f(3,S),A.u32=S=>new f(4,S),A.u40=S=>new f(5,S),A.u48=S=>new f(6,S),A.nu64=S=>new I(S),A.u16be=S=>new b(2,S),A.u24be=S=>new b(3,S),A.u32be=S=>new b(4,S),A.u40be=S=>new b(5,S),A.u48be=S=>new b(6,S),A.nu64be=S=>new C(S),A.s8=S=>new k(1,S),A.s16=S=>new k(2,S),A.s24=S=>new k(3,S),A.s32=S=>new k(4,S),A.s40=S=>new k(5,S),A.s48=S=>new k(6,S),A.ns64=S=>new q(S),A.s16be=S=>new p(2,S),A.s24be=S=>new p(3,S),A.s32be=S=>new p(4,S),A.s40be=S=>new p(5,S),A.s48be=S=>new p(6,S),A.ns64be=S=>new U(S),A.f32=S=>new H(S),A.f32be=S=>new j(S),A.f64=S=>new J(S),A.f64be=S=>new se(S),A.struct=(S,u,l)=>new y(S,u,l),A.bits=(S,u,l)=>new v(S,u,l),A.seq=(S,u,l)=>new Y(S,u,l),A.union=(S,u,l)=>new R(S,u,l),A.unionLayoutDiscriminator=(S,u)=>new T(S,u),A.blob=(S,u)=>new G(S,u),A.cstr=S=>new $(S),A.utf8=(S,u)=>new W(S,u),A.constant=(S,u)=>new X(S,u),A}var h=Oi(),Ni=8078e3,Pi=8078001,qi=8078004,Fi=8078005,Di=8078006,zi=8078011;function Cs(r){return Array.isArray(r)?"%5B"+r.map(Cs).join("%2C%20")+"%5D":typeof r=="bigint"?`${r}n`:encodeURIComponent(String(r!=null&&Object.getPrototypeOf(r)===null?{...r}:r))}function Mi([r,e]){return`${r}=${Cs(e)}`}function Ki(r){const e=Object.entries(r).map(Mi).join("&");return btoa(e)}function Hi(r,e={}){{let t=`Solana error #${r}; Decode this error by running \`npx @solana/errors decode -- ${r}`;return Object.keys(e).length&&(t+=` '${Ki(e)}'`),`${t}\``}}var St=class extends Error{cause=this.cause;context;constructor(...[r,e]){let t,n;if(e){const{cause:o,...i}=e;o&&(n={cause:o}),Object.keys(i).length>0&&(t=i)}const s=Hi(r,t);super(s,n),this.context={__code:r,...t},this.name="SolanaError"}};function $i(r,e){return"fixedSize"in e?e.fixedSize:e.getSizeFromValue(r)}function Wi(r){return Object.freeze({...r,encode:e=>{const t=new Uint8Array($i(e,r));return r.write(e,t,0),t}})}function ji(r){return Object.freeze({...r,decode:(e,t=0)=>r.read(e,t)[0]})}function yt(r){return"fixedSize"in r&&typeof r.fixedSize=="number"}function Vi(r,e){if(yt(r)!==yt(e))throw new St(qi);if(yt(r)&&yt(e)&&r.fixedSize!==e.fixedSize)throw new St(Fi,{decoderFixedSize:e.fixedSize,encoderFixedSize:r.fixedSize});if(!yt(r)&&!yt(e)&&r.maxSize!==e.maxSize)throw new St(Di,{decoderMaxSize:e.maxSize,encoderMaxSize:r.maxSize});return{...e,...r,decode:e.decode,encode:r.encode,read:e.read,write:r.write}}function Gi(r,e,t=0){if(e.length-t<=0)throw new St(Ni,{codecDescription:r})}function Zi(r,e,t,n=0){const s=t.length-n;if(s<e)throw new St(Pi,{bytesLength:s,codecDescription:r,expected:e})}function Yi(r,e,t,n){if(n<e||n>t)throw new St(zi,{codecDescription:r,max:t,min:e,value:n})}function Ts(r){return r?.endian!==1}function Xi(r){return Wi({fixedSize:r.size,write(e,t,n){r.range&&Yi(r.name,r.range[0],r.range[1],e);const s=new ArrayBuffer(r.size);return r.set(new DataView(s),e,Ts(r.config)),t.set(new Uint8Array(s),n),n+r.size}})}function Ji(r){return ji({fixedSize:r.size,read(e,t=0){Gi(r.name,e,t),Zi(r.name,r.size,e,t);const n=new DataView(Qi(e,t,r.size));return[r.get(n,Ts(r.config)),t+r.size]}})}function Qi(r,e,t){const n=r.byteOffset+(e??0),s=t??r.byteLength;return r.buffer.slice(n,n+s)}var ec=(r={})=>Xi({config:r,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),tc=(r={})=>Ji({config:r,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),nc=(r={})=>Vi(ec(r),tc(r));class rc extends TypeError{constructor(e,t){let n;const{message:s,explanation:o,...i}=e,{path:a}=e,c=a.length===0?s:`At path: ${a.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function sc(r){return qt(r)&&typeof r[Symbol.iterator]=="function"}function qt(r){return typeof r=="object"&&r!=null}function nn(r){return qt(r)&&!Array.isArray(r)}function Ne(r){return typeof r=="symbol"?r.toString():typeof r=="string"?JSON.stringify(r):`${r}`}function oc(r){const{done:e,value:t}=r.next();return e?void 0:t}function ic(r,e,t,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:s,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${Ne(n)}\``}=r;return{value:n,type:i,refinement:a,key:s[s.length-1],path:s,branch:o,...r,message:c}}function*Cr(r,e,t,n){sc(r)||(r=[r]);for(const s of r){const o=ic(s,e,t,n);o&&(yield o)}}function*tr(r,e,t={}){const{path:n=[],branch:s=[r],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:s,mask:i};o&&(r=e.coercer(r,a));let c="valid";for(const f of e.validator(r,a))f.explanation=t.message,c="not_valid",yield[f,void 0];for(let[f,b,k]of e.entries(r,a)){const p=tr(b,k,{path:f===void 0?n:[...n,f],branch:f===void 0?s:[...s,b],coerce:o,mask:i,message:t.message});for(const g of p)g[0]?(c=g[0].refinement!=null?"not_refined":"not_valid",yield[g[0],void 0]):o&&(b=g[1],f===void 0?r=b:r instanceof Map?r.set(f,b):r instanceof Set?r.add(b):qt(r)&&(b!==void 0||f in r)&&(r[f]=b))}if(c!=="not_valid")for(const f of e.refiner(r,a))f.explanation=t.message,c="not_refined",yield[f,void 0];c==="valid"&&(yield[void 0,r])}let De=class{constructor(e){const{type:t,schema:n,validator:s,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,s?this.validator=(c,f)=>{const b=s(c,f);return Cr(b,f,this,c)}:this.validator=()=>[],o?this.refiner=(c,f)=>{const b=o(c,f);return Cr(b,f,this,c)}:this.refiner=()=>[]}assert(e,t){return cc(e,this,t)}create(e,t){return D(e,this,t)}is(e){return Ls(e,this)}mask(e,t){return ac(e,this,t)}validate(e,t={}){return Ft(e,this,t)}};function cc(r,e,t){const n=Ft(r,e,{message:t});if(n[0])throw n[0]}function D(r,e,t){const n=Ft(r,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function ac(r,e,t){const n=Ft(r,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Ls(r,e){return!Ft(r,e)[0]}function Ft(r,e,t={}){const n=tr(r,e,t),s=oc(n);return s[0]?[new rc(s[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,s[1]]}function lt(r,e){return new De({type:r,schema:null,validator:e})}function uc(){return lt("any",()=>!0)}function z(r){return new De({type:"array",schema:r,*entries(e){if(r&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,r]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${Ne(e)}`}})}function Fe(){return lt("boolean",r=>typeof r=="boolean")}function nr(r){return lt("instance",e=>e instanceof r||`Expected a \`${r.name}\` instance, but received: ${Ne(e)}`)}function ue(r){const e=Ne(r),t=typeof r;return new De({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?r:null,validator(n){return n===r||`Expected the literal \`${e}\`, but received: ${Ne(n)}`}})}function lc(){return lt("never",()=>!1)}function M(r){return new De({...r,validator:(e,t)=>e===null||r.validator(e,t),refiner:(e,t)=>e===null||r.refiner(e,t)})}function _(){return lt("number",r=>typeof r=="number"&&!isNaN(r)||`Expected a number, but received: ${Ne(r)}`)}function Z(r){return new De({...r,validator:(e,t)=>e===void 0||r.validator(e,t),refiner:(e,t)=>e===void 0||r.refiner(e,t)})}function Us(r,e){return new De({type:"record",schema:null,*entries(t){if(qt(t))for(const n in t){const s=t[n];yield[n,n,r],yield[n,s,e]}},validator(t){return nn(t)||`Expected an object, but received: ${Ne(t)}`},coercer(t){return nn(t)?{...t}:t}})}function F(){return lt("string",r=>typeof r=="string"||`Expected a string, but received: ${Ne(r)}`)}function rr(r){const e=lc();return new De({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(r.length,t.length);for(let s=0;s<n;s++)yield[s,t[s],r[s]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${Ne(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function N(r){const e=Object.keys(r);return new De({type:"type",schema:r,*entries(t){if(qt(t))for(const n of e)yield[n,t[n],r[n]]},validator(t){return nn(t)||`Expected an object, but received: ${Ne(t)}`},coercer(t){return nn(t)?{...t}:t}})}function Ae(r){const e=r.map(t=>t.type).join(" | ");return new De({type:"union",schema:null,coercer(t,n){for(const s of r){const[o,i]=s.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){const s=[];for(const o of r){const[...i]=tr(t,o,n),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${Ne(t)}`,...s]}})}function vt(){return lt("unknown",()=>!0)}function Dt(r,e,t){return new De({...r,coercer:(n,s)=>Ls(n,e)?r.coercer(t(n,s),s):r.coercer(n,s)})}const Os=Zr(vo);var Tn,Tr;function fc(){if(Tr)return Tn;Tr=1;const r=Os.v4;return Tn=function(t,n,s,o){if(typeof t!="string")throw new TypeError(t+" must be a string");o=o||{};const i=typeof o.version=="number"?o.version:2;if(i!==1&&i!==2)throw new TypeError(i+" must be 1 or 2");const a={method:t};if(i===2&&(a.jsonrpc="2.0"),n){if(typeof n!="object"&&!Array.isArray(n))throw new TypeError(n+" must be an object, array or omitted");a.params=n}if(typeof s>"u"){const c=typeof o.generator=="function"?o.generator:function(){return r()};a.id=c(a,o)}else i===2&&s===null?o.notificationIdNull&&(a.id=null):a.id=s;return a},Tn}var Ln,Lr;function dc(){if(Lr)return Ln;Lr=1;const r=Os.v4,e=fc(),t=function(n,s){if(!(this instanceof t))return new t(n,s);s||(s={}),this.options={reviver:typeof s.reviver<"u"?s.reviver:null,replacer:typeof s.replacer<"u"?s.replacer:null,generator:typeof s.generator<"u"?s.generator:function(){return r()},version:typeof s.version<"u"?s.version:2,notificationIdNull:typeof s.notificationIdNull=="boolean"?s.notificationIdNull:!1},this.callServer=n};return Ln=t,t.prototype.request=function(n,s,o,i){const a=this;let c=null;const f=Array.isArray(n)&&typeof s=="function";if(this.options.version===1&&f)throw new TypeError("JSON-RPC 1.0 does not support batching");if(f||!f&&n&&typeof n=="object"&&typeof s=="function")i=s,c=n;else{typeof o=="function"&&(i=o,o=void 0);const p=typeof i=="function";try{c=e(n,s,o,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(g){if(p)return i(g);throw g}if(!p)return c}let k;try{k=JSON.stringify(c,this.options.replacer)}catch(p){return i(p)}return this.callServer(k,function(p,g){a._parseResponse(p,g,i)}),c},t.prototype._parseResponse=function(n,s,o){if(n){o(n);return}if(!s)return o();let i;try{i=JSON.parse(s,this.options.reviver)}catch(a){return o(a)}if(o.length===3)if(Array.isArray(i)){const a=function(f){return typeof f.error<"u"},c=function(f){return!a(f)};return o(null,i.filter(a),i.filter(c))}else return o(null,i.error,i.result);o(null,i)},Ln}var hc=dc();const gc=Vn(hc);var pc=class extends Yr{socket;constructor(r,e,t){super(),this.socket=new window.WebSocket(r,t),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=n=>this.emit("message",n.data),this.socket.onerror=n=>this.emit("error",n),this.socket.onclose=n=>{this.emit("close",n.code,n.reason)}}send(r,e,t){const n=t||e;try{this.socket.send(r),n()}catch(s){n(s)}}close(r,e){this.socket.close(r,e)}addEventListener(r,e,t){this.socket.addEventListener(r,e,t)}};function yc(r,e){return new pc(r,e)}var bc=class{encode(r){return JSON.stringify(r)}decode(r){return JSON.parse(r)}},mc=class extends Yr{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(r,e="ws://localhost:8080",{autoconnect:t=!0,reconnect:n=!0,reconnect_interval:s=1e3,max_reconnects:o=5,...i}={},a,c){super(),this.webSocketFactory=r,this.queue={},this.rpc_id=0,this.address=e,this.autoconnect=t,this.ready=!1,this.reconnect=n,this.reconnect_timer_id=void 0,this.reconnect_interval=s,this.max_reconnects=o,this.rest_options=i,this.current_reconnects=0,this.generate_request_id=a||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),c?this.dataPack=c:this.dataPack=new bc,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(r,e,t,n){return!n&&typeof t=="object"&&(n=t,t=null),new Promise((s,o)=>{if(!this.ready)return o(new Error("socket not ready"));const i=this.generate_request_id(r,e),a={jsonrpc:"2.0",method:r,params:e||void 0,id:i};this.socket.send(this.dataPack.encode(a),n,c=>{if(c)return o(c);this.queue[i]={promise:[s,o]},t&&(this.queue[i].timeout=setTimeout(()=>{delete this.queue[i],o(new Error("reply timeout"))},t))})})}async login(r){const e=await this.call("rpc.login",r);if(!e)throw new Error("authentication failed");return e}async listMethods(){return await this.call("__listMethods")}notify(r,e){return new Promise((t,n)=>{if(!this.ready)return n(new Error("socket not ready"));const s={jsonrpc:"2.0",method:r,params:e};this.socket.send(this.dataPack.encode(s),o=>{if(o)return n(o);t()})})}async subscribe(r){typeof r=="string"&&(r=[r]);const e=await this.call("rpc.on",r);if(typeof r=="string"&&e[r]!=="ok")throw new Error("Failed subscribing to an event '"+r+"' with: "+e[r]);return e}async unsubscribe(r){typeof r=="string"&&(r=[r]);const e=await this.call("rpc.off",r);if(typeof r=="string"&&e[r]!=="ok")throw new Error("Failed unsubscribing from an event with: "+e);return e}close(r,e){this.socket&&this.socket.close(r||1e3,e)}setAutoReconnect(r){this.reconnect=r}setReconnectInterval(r){this.reconnect_interval=r}setMaxReconnects(r){this.max_reconnects=r}getCurrentReconnects(){return this.current_reconnects}getMaxReconnects(){return this.max_reconnects}isReconnecting(){return this.reconnect_timer_id!==void 0}willReconnect(){return this.reconnect&&(this.max_reconnects===0||this.current_reconnects<this.max_reconnects)}_connect(r,e){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(r,e),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:t})=>{t instanceof ArrayBuffer&&(t=re.Buffer.from(t).toString());try{t=this.dataPack.decode(t)}catch{return}if(t.notification&&this.listeners(t.notification).length){if(!Object.keys(t.params).length)return this.emit(t.notification);const n=[t.notification];if(t.params.constructor===Object)n.push(t.params);else for(let s=0;s<t.params.length;s++)n.push(t.params[s]);return Promise.resolve().then(()=>{this.emit.apply(this,n)})}if(!this.queue[t.id])return t.method?Promise.resolve().then(()=>{this.emit(t.method,t?.params)}):void 0;"error"in t=="result"in t&&this.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[t.id].timeout&&clearTimeout(this.queue[t.id].timeout),t.error?this.queue[t.id].promise[1](t.error):this.queue[t.id].promise[0](t.result),delete this.queue[t.id]}),this.socket.addEventListener("error",t=>this.emit("error",t)),this.socket.addEventListener("close",({code:t,reason:n})=>{this.ready&&setTimeout(()=>this.emit("close",t,n),0),this.ready=!1,this.socket=void 0,t!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)?this.reconnect_timer_id=setTimeout(()=>this._connect(r,e),this.reconnect_interval):this.reconnect&&this.max_reconnects>0&&this.current_reconnects>=this.max_reconnects&&setTimeout(()=>this.emit("max_reconnects_reached",t,n),1))})}};class Ns extends ss{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ns(e);const n=Gn(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(n.length>s?e.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),kt(o)}update(e){return Gt(this),this.iHash.update(e),this}digestInto(e){Gt(this),at(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ps=(r,e,t)=>new Ns(r,e).update(t).digest();Ps.create=(r,e)=>new Ns(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ur=(r,e)=>(r+(r>=0?e:-e)/qs)/e;function wc(r,e,t){const[[n,s],[o,i]]=e,a=Ur(i*r,t),c=Ur(-s*r,t);let f=r-a*n-c*o,b=-a*s-c*i;const k=f<je,p=b<je;k&&(f=-f),p&&(b=-b);const g=Ot(Math.ceil(fs(t)/2))+Et;if(f<je||f>=g||b<je||b>=g)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:k,k1:f,k2neg:p,k2:b}}function Kn(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function Un(r,e){const t={};for(let n of Object.keys(e))t[n]=r[n]===void 0?e[n]:r[n];return ct(t.lowS,"lowS"),ct(t.prehash,"prehash"),t.format!==void 0&&Kn(t.format),t}class Sc extends Error{constructor(e=""){super(e)}}const Ke={Err:Sc,_tlv:{encode:(r,e)=>{const{Err:t}=Ke;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=$t(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const o=n>127?$t(s.length/2|128):"";return $t(r)+o+s+e},decode(r,e){const{Err:t}=Ke;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const f=e.subarray(n,n+c);if(f.length!==c)throw new t("tlv.decode: length bytes not complete");if(f[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const b of f)i=i<<8|b;if(n+=c,i<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+i);if(a.length!==i)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+i)}}},_int:{encode(r){const{Err:e}=Ke;if(r<je)throw new e("integer: negative integers are not allowed");let t=$t(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=Ke;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return fn(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=Ke,s=de("signature",r),{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:f,l:b}=n.decode(2,c);if(b.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(f)}},hexFromSig(r){const{_tlv:e,_int:t}=Ke,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),o=n+s;return e.encode(48,o)}},je=BigInt(0),Et=BigInt(1),qs=BigInt(2),Wt=BigInt(3),Ec=BigInt(4);function mt(r,e){const{BYTES:t}=r;let n;if(typeof e=="bigint")n=e;else{let s=de("private key",e);try{n=r.fromBytes(s)}catch{throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`)}}if(!r.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function xc(r,e={}){const t=vs("weierstrass",r,e),{Fp:n,Fn:s}=t;let o=t.CURVE;const{h:i,n:a}=o;Nt(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=e;if(c&&(!n.is0(o.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const f=Ds(n,s);function b(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function k(R,B,x){const{x:v,y:P}=B.toAffine(),K=n.toBytes(v);if(ct(x,"isCompressed"),x){b();const G=!n.isOdd(P);return qe(Fs(G),K)}else return qe(Uint8Array.of(4),K,n.toBytes(P))}function p(R){Oe(R,void 0,"Point");const{publicKey:B,publicKeyUncompressed:x}=f,v=R.length,P=R[0],K=R.subarray(1);if(v===B&&(P===2||P===3)){const G=n.fromBytes(K);if(!n.isValid(G))throw new Error("bad point: is not on curve, wrong x");const $=m(G);let W;try{W=n.sqrt($)}catch(u){const l=u instanceof Error?": "+u.message:"";throw new Error("bad point: is not on curve, sqrt error"+l)}b();const X=n.isOdd(W);return(P&1)===1!==X&&(W=n.neg(W)),{x:G,y:W}}else if(v===x&&P===4){const G=n.BYTES,$=n.fromBytes(K.subarray(0,G)),W=n.fromBytes(K.subarray(G,G*2));if(!I($,W))throw new Error("bad point: is not on curve");return{x:$,y:W}}else throw new Error(`bad point: got length ${v}, expected compressed=${B} or uncompressed=${x}`)}const g=e.toBytes||k,E=e.fromBytes||p;function m(R){const B=n.sqr(R),x=n.mul(B,R);return n.add(n.add(x,n.mul(R,o.a)),o.b)}function I(R,B){const x=n.sqr(B),v=m(R);return n.eql(x,v)}if(!I(o.Gx,o.Gy))throw new Error("bad curve params: generator point");const C=n.mul(n.pow(o.a,Wt),Ec),q=n.mul(n.sqr(o.b),BigInt(27));if(n.is0(n.add(C,q)))throw new Error("bad curve params: a or b");function U(R,B,x=!1){if(!n.isValid(B)||x&&n.is0(B))throw new Error(`bad point coordinate ${R}`);return B}function H(R){if(!(R instanceof y))throw new Error("ProjectivePoint expected")}function j(R){if(!c||!c.basises)throw new Error("no endo");return wc(R,c.basises,s.ORDER)}const J=Yt((R,B)=>{const{X:x,Y:v,Z:P}=R;if(n.eql(P,n.ONE))return{x,y:v};const K=R.is0();B==null&&(B=K?n.ONE:n.inv(P));const G=n.mul(x,B),$=n.mul(v,B),W=n.mul(P,B);if(K)return{x:n.ZERO,y:n.ZERO};if(!n.eql(W,n.ONE))throw new Error("invZ was invalid");return{x:G,y:$}}),se=Yt(R=>{if(R.is0()){if(e.allowInfinityPoint&&!n.is0(R.Y))return;throw new Error("bad point: ZERO")}const{x:B,y:x}=R.toAffine();if(!n.isValid(B)||!n.isValid(x))throw new Error("bad point: x or y not field elements");if(!I(B,x))throw new Error("bad point: equation left != right");if(!R.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Y(R,B,x,v,P){return x=new y(n.mul(x.X,R),x.Y,x.Z),B=Xt(v,B),x=Xt(P,x),B.add(x)}class y{constructor(B,x,v){this.X=U("x",B),this.Y=U("y",x,!0),this.Z=U("z",v),Object.freeze(this)}static CURVE(){return o}static fromAffine(B){const{x,y:v}=B||{};if(!B||!n.isValid(x)||!n.isValid(v))throw new Error("invalid affine point");if(B instanceof y)throw new Error("projective point not allowed");return n.is0(x)&&n.is0(v)?y.ZERO:new y(x,v,n.ONE)}static fromBytes(B){const x=y.fromAffine(E(Oe(B,void 0,"point")));return x.assertValidity(),x}static fromHex(B){return y.fromBytes(de("pointHex",B))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(B=8,x=!0){return T.createCache(this,B),x||this.multiply(Wt),this}assertValidity(){se(this)}hasEvenY(){const{y:B}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(B)}equals(B){H(B);const{X:x,Y:v,Z:P}=this,{X:K,Y:G,Z:$}=B,W=n.eql(n.mul(x,$),n.mul(K,P)),X=n.eql(n.mul(v,$),n.mul(G,P));return W&&X}negate(){return new y(this.X,n.neg(this.Y),this.Z)}double(){const{a:B,b:x}=o,v=n.mul(x,Wt),{X:P,Y:K,Z:G}=this;let $=n.ZERO,W=n.ZERO,X=n.ZERO,S=n.mul(P,P),u=n.mul(K,K),l=n.mul(G,G),d=n.mul(P,K);return d=n.add(d,d),X=n.mul(P,G),X=n.add(X,X),$=n.mul(B,X),W=n.mul(v,l),W=n.add($,W),$=n.sub(u,W),W=n.add(u,W),W=n.mul($,W),$=n.mul(d,$),X=n.mul(v,X),l=n.mul(B,l),d=n.sub(S,l),d=n.mul(B,d),d=n.add(d,X),X=n.add(S,S),S=n.add(X,S),S=n.add(S,l),S=n.mul(S,d),W=n.add(W,S),l=n.mul(K,G),l=n.add(l,l),S=n.mul(l,d),$=n.sub($,S),X=n.mul(l,u),X=n.add(X,X),X=n.add(X,X),new y($,W,X)}add(B){H(B);const{X:x,Y:v,Z:P}=this,{X:K,Y:G,Z:$}=B;let W=n.ZERO,X=n.ZERO,S=n.ZERO;const u=o.a,l=n.mul(o.b,Wt);let d=n.mul(x,K),L=n.mul(v,G),O=n.mul(P,$),ee=n.add(x,v),te=n.add(K,G);ee=n.mul(ee,te),te=n.add(d,L),ee=n.sub(ee,te),te=n.add(x,P);let ae=n.add(K,$);return te=n.mul(te,ae),ae=n.add(d,O),te=n.sub(te,ae),ae=n.add(v,P),W=n.add(G,$),ae=n.mul(ae,W),W=n.add(L,O),ae=n.sub(ae,W),S=n.mul(u,te),W=n.mul(l,O),S=n.add(W,S),W=n.sub(L,S),S=n.add(L,S),X=n.mul(W,S),L=n.add(d,d),L=n.add(L,d),O=n.mul(u,O),te=n.mul(l,te),L=n.add(L,O),O=n.sub(d,O),O=n.mul(u,O),te=n.add(te,O),d=n.mul(L,te),X=n.add(X,d),d=n.mul(ae,te),W=n.mul(ee,W),W=n.sub(W,d),d=n.mul(ee,L),S=n.mul(ae,S),S=n.add(S,d),new y(W,X,S)}subtract(B){return this.add(B.negate())}is0(){return this.equals(y.ZERO)}multiply(B){const{endo:x}=e;if(!s.isValidNot0(B))throw new Error("invalid scalar: out of range");let v,P;const K=G=>T.cached(this,G,$=>ot(y,$));if(x){const{k1neg:G,k1:$,k2neg:W,k2:X}=j(B),{p:S,f:u}=K($),{p:l,f:d}=K(X);P=u.add(d),v=Y(x.beta,S,l,G,W)}else{const{p:G,f:$}=K(B);v=G,P=$}return ot(y,[v,P])[0]}multiplyUnsafe(B){const{endo:x}=e,v=this;if(!s.isValid(B))throw new Error("invalid scalar: out of range");if(B===je||v.is0())return y.ZERO;if(B===Et)return v;if(T.hasCache(this))return this.multiply(B);if(x){const{k1neg:P,k1:K,k2neg:G,k2:$}=j(B),{p1:W,p2:X}=ai(y,v,K,$);return Y(x.beta,W,X,P,G)}else return T.unsafe(v,B)}multiplyAndAddUnsafe(B,x,v){const P=this.multiplyUnsafe(x).add(B.multiplyUnsafe(v));return P.is0()?void 0:P}toAffine(B){return J(this,B)}isTorsionFree(){const{isTorsionFree:B}=e;return i===Et?!0:B?B(y,this):T.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:B}=e;return i===Et?this:B?B(y,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(B=!0){return ct(B,"isCompressed"),this.assertValidity(),g(y,this,B)}toHex(B=!0){return it(this.toBytes(B))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(B=!0){return this.toBytes(B)}_setWindowSize(B){this.precompute(B)}static normalizeZ(B){return ot(y,B)}static msm(B,x){return As(y,s,B,x)}static fromPrivateKey(B){return y.BASE.multiply(mt(s,B))}}y.BASE=new y(o.Gx,o.Gy,n.ONE),y.ZERO=new y(n.ZERO,n.ONE,n.ZERO),y.Fp=n,y.Fn=s;const w=s.BITS,T=new _s(y,e.endo?Math.ceil(w/2):w);return y.BASE.precompute(8),y}function Fs(r){return Uint8Array.of(r?2:3)}function Ds(r,e){return{secretKey:e.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function kc(r,e={}){const{Fn:t}=r,n=e.randomBytes||Zn,s=Object.assign(Ds(r.Fp,t),{seed:xs(t.ORDER)});function o(g){try{return!!mt(t,g)}catch{return!1}}function i(g,E){const{publicKey:m,publicKeyUncompressed:I}=s;try{const C=g.length;return E===!0&&C!==m||E===!1&&C!==I?!1:!!r.fromBytes(g)}catch{return!1}}function a(g=n(s.seed)){return oi(Oe(g,s.seed,"seed"),t.ORDER)}function c(g,E=!0){return r.BASE.multiply(mt(t,g)).toBytes(E)}function f(g){const E=a(g);return{secretKey:E,publicKey:c(E)}}function b(g){if(typeof g=="bigint")return!1;if(g instanceof r)return!0;const{secretKey:E,publicKey:m,publicKeyUncompressed:I}=s;if(t.allowedLengths||E===m)return;const C=de("key",g).length;return C===m||C===I}function k(g,E,m=!0){if(b(g)===!0)throw new Error("first arg must be private key");if(b(E)===!1)throw new Error("second arg must be public key");const I=mt(t,g);return r.fromHex(E).multiply(I).toBytes(m)}return Object.freeze({getPublicKey:c,getSharedSecret:k,keygen:f,Point:r,utils:{isValidSecretKey:o,isValidPublicKey:i,randomSecretKey:a,isValidPrivateKey:o,randomPrivateKey:a,normPrivateKeyToScalar:g=>mt(t,g),precompute(g=8,E=r.BASE){return E.precompute(g,!1)}},lengths:s})}function Bc(r,e,t={}){ns(e),Nt(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=t.randomBytes||Zn,s=t.hmac||((x,...v)=>Ps(e,x,qe(...v))),{Fp:o,Fn:i}=r,{ORDER:a,BITS:c}=i,{keygen:f,getPublicKey:b,getSharedSecret:k,utils:p,lengths:g}=kc(r,t),E={prehash:!1,lowS:typeof t.lowS=="boolean"?t.lowS:!1,format:void 0,extraEntropy:!1},m="compact";function I(x){const v=a>>Et;return x>v}function C(x,v){if(!i.isValidNot0(v))throw new Error(`invalid signature ${x}: out of range 1..Point.Fn.ORDER`);return v}function q(x,v){Kn(v);const P=g.signature,K=v==="compact"?P:v==="recovered"?P+1:void 0;return Oe(x,K,`${v} signature`)}class U{constructor(v,P,K){this.r=C("r",v),this.s=C("s",P),K!=null&&(this.recovery=K),Object.freeze(this)}static fromBytes(v,P=m){q(v,P);let K;if(P==="der"){const{r:X,s:S}=Ke.toSig(Oe(v));return new U(X,S)}P==="recovered"&&(K=v[0],P="compact",v=v.subarray(1));const G=i.BYTES,$=v.subarray(0,G),W=v.subarray(G,G*2);return new U(i.fromBytes($),i.fromBytes(W),K)}static fromHex(v,P){return this.fromBytes(Zt(v),P)}addRecoveryBit(v){return new U(this.r,this.s,v)}recoverPublicKey(v){const P=o.ORDER,{r:K,s:G,recovery:$}=this;if($==null||![0,1,2,3].includes($))throw new Error("recovery id invalid");if(a*qs<P&&$>1)throw new Error("recovery id is ambiguous for h>1 curve");const X=$===2||$===3?K+a:K;if(!o.isValid(X))throw new Error("recovery id 2 or 3 invalid");const S=o.toBytes(X),u=r.fromBytes(qe(Fs(($&1)===0),S)),l=i.inv(X),d=j(de("msgHash",v)),L=i.create(-d*l),O=i.create(G*l),ee=r.BASE.multiplyUnsafe(L).add(u.multiplyUnsafe(O));if(ee.is0())throw new Error("point at infinify");return ee.assertValidity(),ee}hasHighS(){return I(this.s)}toBytes(v=m){if(Kn(v),v==="der")return Zt(Ke.hexFromSig(this));const P=i.toBytes(this.r),K=i.toBytes(this.s);if(v==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return qe(Uint8Array.of(this.recovery),P,K)}return qe(P,K)}toHex(v){return it(this.toBytes(v))}assertValidity(){}static fromCompact(v){return U.fromBytes(de("sig",v),"compact")}static fromDER(v){return U.fromBytes(de("sig",v),"der")}normalizeS(){return this.hasHighS()?new U(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return it(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return it(this.toBytes("compact"))}}const H=t.bits2int||function(v){if(v.length>8192)throw new Error("input is too large");const P=fn(v),K=v.length*8-c;return K>0?P>>BigInt(K):P},j=t.bits2int_modN||function(v){return i.create(H(v))},J=Ot(c);function se(x){return Mn("num < 2^"+c,x,je,J),i.toBytes(x)}function Y(x,v){return Oe(x,void 0,"message"),v?Oe(e(x),void 0,"prehashed message"):x}function y(x,v,P){if(["recovered","canonical"].some(L=>L in P))throw new Error("sign() legacy options not supported");const{lowS:K,prehash:G,extraEntropy:$}=Un(P,E);x=Y(x,G);const W=j(x),X=mt(i,v),S=[se(X),se(W)];if($!=null&&$!==!1){const L=$===!0?n(g.secretKey):$;S.push(de("extraEntropy",L))}const u=qe(...S),l=W;function d(L){const O=H(L);if(!i.isValidNot0(O))return;const ee=i.inv(O),te=r.BASE.multiply(O).toAffine(),ae=i.create(te.x);if(ae===je)return;const nt=i.create(ee*i.create(l+ae*X));if(nt===je)return;let ur=(te.x===ae?0:2)|Number(te.y&Et),lr=nt;return K&&I(nt)&&(lr=i.neg(nt),ur^=1),new U(ae,lr,ur)}return{seed:u,k2sig:d}}function w(x,v,P={}){x=de("message",x);const{seed:K,k2sig:G}=y(x,v,P);return Zo(e.outputLen,i.BYTES,s)(K,G)}function T(x){let v;const P=typeof x=="string"||Ut(x),K=!P&&x!==null&&typeof x=="object"&&typeof x.r=="bigint"&&typeof x.s=="bigint";if(!P&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(K)v=new U(x.r,x.s);else if(P){try{v=U.fromBytes(de("sig",x),"der")}catch(G){if(!(G instanceof Ke.Err))throw G}if(!v)try{v=U.fromBytes(de("sig",x),"compact")}catch{return!1}}return v||!1}function R(x,v,P,K={}){const{lowS:G,prehash:$,format:W}=Un(K,E);if(P=de("publicKey",P),v=Y(de("message",v),$),"strict"in K)throw new Error("options.strict was renamed to lowS");const X=W===void 0?T(x):U.fromBytes(de("sig",x),W);if(X===!1)return!1;try{const S=r.fromBytes(P);if(G&&X.hasHighS())return!1;const{r:u,s:l}=X,d=j(v),L=i.inv(l),O=i.create(d*L),ee=i.create(u*L),te=r.BASE.multiplyUnsafe(O).add(S.multiplyUnsafe(ee));return te.is0()?!1:i.create(te.x)===u}catch{return!1}}function B(x,v,P={}){const{prehash:K}=Un(P,E);return v=Y(v,K),U.fromBytes(x,"recovered").recoverPublicKey(v).toBytes()}return Object.freeze({keygen:f,getPublicKey:b,getSharedSecret:k,utils:p,lengths:g,Point:r,sign:w,verify:R,recoverPublicKey:B,Signature:U,hash:e})}function _c(r){const e={a:r.a,b:r.b,p:r.Fp.ORDER,n:r.n,h:r.h,Gx:r.Gx,Gy:r.Gy},t=r.Fp;let n=r.allowedPrivateKeyLengths?Array.from(new Set(r.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0;const s=ut(e.n,{BITS:r.nBitLength,allowedLengths:n,modFromBytes:r.wrapPrivateKey}),o={Fp:t,Fn:s,allowInfinityPoint:r.allowInfinityPoint,endo:r.endo,isTorsionFree:r.isTorsionFree,clearCofactor:r.clearCofactor,fromBytes:r.fromBytes,toBytes:r.toBytes};return{CURVE:e,curveOpts:o}}function Ac(r){const{CURVE:e,curveOpts:t}=_c(r),n={hmac:r.hmac,randomBytes:r.randomBytes,lowS:r.lowS,bits2int:r.bits2int,bits2int_modN:r.bits2int_modN};return{CURVE:e,curveOpts:t,hash:r.hash,ecdsaOpts:n}}function vc(r,e){const t=e.Point;return Object.assign({},e,{ProjectivePoint:t,CURVE:Object.assign({},r,Ss(t.Fn.ORDER,t.Fn.BITS))})}function Ic(r){const{CURVE:e,curveOpts:t,hash:n,ecdsaOpts:s}=Ac(r),o=xc(e,t),i=Bc(o,n,s);return vc(r,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Rc(r,e){const t=n=>Ic({...r,hash:n});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sr={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Cc={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Or=BigInt(2);function Tc(r){const e=sr.p,t=BigInt(3),n=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),f=r*r*r%e,b=f*f*r%e,k=fe(b,t,e)*b%e,p=fe(k,t,e)*b%e,g=fe(p,Or,e)*f%e,E=fe(g,s,e)*g%e,m=fe(E,o,e)*E%e,I=fe(m,a,e)*m%e,C=fe(I,c,e)*I%e,q=fe(C,a,e)*m%e,U=fe(q,t,e)*b%e,H=fe(U,i,e)*E%e,j=fe(H,n,e)*f%e,J=fe(j,Or,e);if(!Hn.eql(Hn.sqr(J),r))throw new Error("Cannot find square root");return J}const Hn=ut(sr.p,{sqrt:Tc}),Lc=Rc({...sr,Fp:Hn,lowS:!0,endo:Cc},as);Pt.utils.randomPrivateKey;Pt.getPublicKey;function Nr(r){try{return Pt.ExtendedPoint.fromHex(r),!0}catch{return!1}}const Uc=(r,e)=>Pt.sign(r,e.slice(0,32)),Oc=Pt.verify,me=r=>re.Buffer.isBuffer(r)?r:r instanceof Uint8Array?re.Buffer.from(r.buffer,r.byteOffset,r.byteLength):re.Buffer.from(r);class Nc{constructor(e){Object.assign(this,e)}encode(){return re.Buffer.from(Cn.serialize(Vt,this))}static decode(e){return Cn.deserialize(Vt,this,e)}static decodeUnchecked(e){return Cn.deserializeUnchecked(Vt,this,e)}}const Vt=new Map;var zs;const Pc=32,et=32;function qc(r){return r._bn!==void 0}let Pr=1;class Q extends Nc{constructor(e){if(super({}),this._bn=void 0,qc(e))this._bn=e._bn;else{if(typeof e=="string"){const t=we.decode(e);if(t.length!=et)throw new Error("Invalid public key input");this._bn=new Br(t)}else this._bn=new Br(e);if(this._bn.byteLength()>et)throw new Error("Invalid public key input")}}static unique(){const e=new Q(Pr);return Pr+=1,new Q(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return we.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(re.Buffer);if(e.length===et)return e;const t=re.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const s=re.Buffer.concat([e.toBuffer(),re.Buffer.from(t),n.toBuffer()]),o=vr(s);return new Q(o)}static createProgramAddressSync(e,t){let n=re.Buffer.alloc(0);e.forEach(function(o){if(o.length>Pc)throw new TypeError("Max seed length exceeded");n=re.Buffer.concat([n,me(o)])}),n=re.Buffer.concat([n,t.toBuffer(),re.Buffer.from("ProgramDerivedAddress")]);const s=vr(n);if(Nr(s))throw new Error("Invalid seeds, address must fall off the curve");return new Q(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,s;for(;n!=0;){try{const o=e.concat(re.Buffer.from([n]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[s,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new Q(e);return Nr(t.toBytes())}}zs=Q;Q.default=new zs("11111111111111111111111111111111");Vt.set(Q,{kind:"struct",fields:[["_bn","u256"]]});new Q("BPFLoader1111111111111111111111111111111111");const xt=1232,Ms=127,Ks=64;class Hs extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Hs.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class $s extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty($s.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Ct extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Ct.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class rn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});const s=o=>{const i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const oe=(r="publicKey")=>h.blob(32,r),wt=(r="string")=>{const e=h.struct([h.u32("length"),h.u32("lengthPadding"),h.blob(h.offset(h.u32(),-8),"chars")],r),t=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(o,i)=>t(o,i).chars.toString(),s.encode=(o,i,a)=>{const c={chars:re.Buffer.from(o,"utf8")};return n(c,i,a)},s.alloc=o=>h.u32().span+h.u32().span+re.Buffer.from(o,"utf8").length,s},Fc=(r="authorized")=>h.struct([oe("staker"),oe("withdrawer")],r),Dc=(r="lockup")=>h.struct([h.ns64("unixTimestamp"),h.ns64("epoch"),oe("custodian")],r),zc=(r="voteInit")=>h.struct([oe("nodePubkey"),oe("authorizedVoter"),oe("authorizedWithdrawer"),h.u8("commission")],r),Mc=(r="voteAuthorizeWithSeedArgs")=>h.struct([h.u32("voteAuthorizationType"),oe("currentAuthorityDerivedKeyOwnerPubkey"),wt("currentAuthorityDerivedKeySeed"),oe("newAuthorized")],r);function Ws(r,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const o=e[s.property];if(Array.isArray(o))return o.length*t(s.elementLayout)}else if("fields"in s)return Ws({layout:s},e[s.property]);return 0};let n=0;return r.layout.fields.forEach(s=>{n+=t(s)}),n}function Ce(r){let e=0,t=0;for(;;){let n=r.shift();if(e|=(n&127)<<t*7,t+=1,(n&128)===0)break}return e}function Te(r,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){r.push(n);break}else n|=128,r.push(n)}}function ge(r,e){if(!r)throw new Error(e||"Assertion failed")}class hn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,s=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||=a.isSigner,c.isWritable||=a.isWritable}}return new hn(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];ge(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{ge(t.length>0,"Expected at least one writable signer key");const[c]=t[0];ge(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new Q(c)),...n.map(([c])=>new Q(c)),...s.map(([c])=>new Q(c)),...o.map(([c])=>new Q(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){const n=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(t(i)){const a=new Q(o),c=e.findIndex(f=>f.equals(a));c>=0&&(ge(c<256,"Max lookup table index exceeded"),n.push(c),s.push(a),this.keyMetaMap.delete(o))}return[n,s]}}const js="Reached end of buffer unexpectedly";function $e(r){if(r.length===0)throw new Error(js);return r.shift()}function Le(r,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>r.length:t>=r.length)throw new Error(js);return r.splice(...e)}class tt{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new Q(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:we.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new rn(this.staticAccountKeys)}static compile(e){const t=hn.compile(e.instructions,e.payerKey),[n,s]=t.getMessageComponents(),i=new rn(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:we.encode(a.data)}));return new tt({header:n,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Te(t,e);const n=this.instructions.map(k=>{const{accounts:p,programIdIndex:g}=k,E=Array.from(we.decode(k.data));let m=[];Te(m,p.length);let I=[];return Te(I,E.length),{programIdIndex:g,keyIndicesCount:re.Buffer.from(m),keyIndices:p,dataLength:re.Buffer.from(I),data:E}});let s=[];Te(s,n.length);let o=re.Buffer.alloc(xt);re.Buffer.from(s).copy(o);let i=s.length;n.forEach(k=>{const g=h.struct([h.u8("programIdIndex"),h.blob(k.keyIndicesCount.length,"keyIndicesCount"),h.seq(h.u8("keyIndex"),k.keyIndices.length,"keyIndices"),h.blob(k.dataLength.length,"dataLength"),h.seq(h.u8("userdatum"),k.data.length,"data")]).encode(k,o,i);i+=g}),o=o.slice(0,i);const a=h.struct([h.blob(1,"numRequiredSignatures"),h.blob(1,"numReadonlySignedAccounts"),h.blob(1,"numReadonlyUnsignedAccounts"),h.blob(t.length,"keyCount"),h.seq(oe("key"),e,"keys"),oe("recentBlockhash")]),c={numRequiredSignatures:re.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:re.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:re.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:re.Buffer.from(t),keys:this.accountKeys.map(k=>me(k.toBytes())),recentBlockhash:we.decode(this.recentBlockhash)};let f=re.Buffer.alloc(2048);const b=a.encode(c,f);return o.copy(f,b),f.slice(0,b+o.length)}static from(e){let t=[...e];const n=$e(t);if(n!==(n&Ms))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=$e(t),o=$e(t),i=Ce(t);let a=[];for(let p=0;p<i;p++){const g=Le(t,0,et);a.push(new Q(re.Buffer.from(g)))}const c=Le(t,0,et),f=Ce(t);let b=[];for(let p=0;p<f;p++){const g=$e(t),E=Ce(t),m=Le(t,0,E),I=Ce(t),C=Le(t,0,I),q=we.encode(re.Buffer.from(C));b.push({programIdIndex:g,accounts:m,data:q})}const k={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:we.encode(re.Buffer.from(c)),accountKeys:a,instructions:b};return new tt(k)}}class sn{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new rn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const s=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const s=e.find(o=>o.key.equals(n.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=hn.compile(e.instructions,e.payerKey),n=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const b of o){const k=t.extractTableLookup(b);if(k!==void 0){const[p,{writable:g,readonly:E}]=k;n.push(p),s.writable.push(...g),s.readonly.push(...E)}}const[i,a]=t.getMessageComponents(),f=new rn(a,s).compileInstructions(e.instructions);return new sn({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:f,addressTableLookups:n})}serialize(){const e=Array();Te(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Te(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Te(o,this.addressTableLookups.length);const i=h.struct([h.u8("prefix"),h.struct([h.u8("numRequiredSignatures"),h.u8("numReadonlySignedAccounts"),h.u8("numReadonlyUnsignedAccounts")],"header"),h.blob(e.length,"staticAccountKeysLength"),h.seq(oe(),this.staticAccountKeys.length,"staticAccountKeys"),oe("recentBlockhash"),h.blob(n.length,"instructionsLength"),h.blob(t.length,"serializedInstructions"),h.blob(o.length,"addressTableLookupsLength"),h.blob(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(xt),f=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(b=>b.toBytes()),recentBlockhash:we.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},a);return a.slice(0,f)}serializeInstructions(){let e=0;const t=new Uint8Array(xt);for(const n of this.compiledInstructions){const s=Array();Te(s,n.accountKeyIndexes.length);const o=Array();Te(o,n.data.length);const i=h.struct([h.u8("programIdIndex"),h.blob(s.length,"encodedAccountKeyIndexesLength"),h.seq(h.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),h.blob(o.length,"encodedDataLength"),h.blob(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(xt);for(const n of this.addressTableLookups){const s=Array();Te(s,n.writableIndexes.length);const o=Array();Te(o,n.readonlyIndexes.length);const i=h.struct([oe("accountKey"),h.blob(s.length,"encodedWritableIndexesLength"),h.seq(h.u8(),n.writableIndexes.length,"writableIndexes"),h.blob(o.length,"encodedReadonlyIndexesLength"),h.seq(h.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=$e(t),s=n&Ms;ge(n!==s,"Expected versioned message but received legacy message");const o=s;ge(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:$e(t),numReadonlySignedAccounts:$e(t),numReadonlyUnsignedAccounts:$e(t)},a=[],c=Ce(t);for(let E=0;E<c;E++)a.push(new Q(Le(t,0,et)));const f=we.encode(Le(t,0,et)),b=Ce(t),k=[];for(let E=0;E<b;E++){const m=$e(t),I=Ce(t),C=Le(t,0,I),q=Ce(t),U=new Uint8Array(Le(t,0,q));k.push({programIdIndex:m,accountKeyIndexes:C,data:U})}const p=Ce(t),g=[];for(let E=0;E<p;E++){const m=new Q(Le(t,0,et)),I=Ce(t),C=Le(t,0,I),q=Ce(t),U=Le(t,0,q);g.push({accountKey:m,writableIndexes:C,readonlyIndexes:U})}return new sn({header:i,staticAccountKeys:a,recentBlockhash:f,compiledInstructions:k,addressTableLookups:g})}}let Je=function(r){return r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID",r}({});const Kc=re.Buffer.alloc(Ks).fill(0);class Ue{constructor(e){this.keys=void 0,this.programId=void 0,this.data=re.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class We{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new Ue(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let m=0;m<t.length;m++)if(t[m].programId===void 0)throw new Error(`Transaction instruction index ${m} has undefined program id`);const s=[],o=[];t.forEach(m=>{m.keys.forEach(C=>{o.push({...C})});const I=m.programId.toString();s.includes(I)||s.push(I)}),s.forEach(m=>{o.push({pubkey:new Q(m),isSigner:!1,isWritable:!1})});const i=[];o.forEach(m=>{const I=m.pubkey.toString(),C=i.findIndex(q=>q.pubkey.toString()===I);C>-1?(i[C].isWritable=i[C].isWritable||m.isWritable,i[C].isSigner=i[C].isSigner||m.isSigner):i.push(m)}),i.sort(function(m,I){if(m.isSigner!==I.isSigner)return m.isSigner?-1:1;if(m.isWritable!==I.isWritable)return m.isWritable?-1:1;const C={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return m.pubkey.toBase58().localeCompare(I.pubkey.toBase58(),"en",C)});const a=i.findIndex(m=>m.pubkey.equals(n));if(a>-1){const[m]=i.splice(a,1);m.isSigner=!0,m.isWritable=!0,i.unshift(m)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const m of this.signatures){const I=i.findIndex(C=>C.pubkey.equals(m.publicKey));if(I>-1)i[I].isSigner||(i[I].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${m.publicKey.toString()}`)}let c=0,f=0,b=0;const k=[],p=[];i.forEach(({pubkey:m,isSigner:I,isWritable:C})=>{I?(k.push(m.toString()),c+=1,C||(f+=1)):(p.push(m.toString()),C||(b+=1))});const g=k.concat(p),E=t.map(m=>{const{data:I,programId:C}=m;return{programIdIndex:g.indexOf(C.toString()),accounts:m.keys.map(q=>g.indexOf(q.pubkey.toString())),data:we.encode(I)}});return E.forEach(m=>{ge(m.programIdIndex>=0),m.accounts.forEach(I=>ge(I>=0))}),new tt({header:{numRequiredSignatures:c,numReadonlySignedAccounts:f,numReadonlyUnsignedAccounts:b},accountKeys:g,recentBlockhash:e,instructions:E})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const s=n.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const o of e){const i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}const s=this._compile();this._partialSign(s,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(s=>{const o=Uc(n,s.secretKey);this._addSignature(s.publicKey,me(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){ge(t.length===64);const n=this.signatures.findIndex(s=>e.equals(s.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=re.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:s,publicKey:o}of this.signatures)s===null?t&&(n.missing||=[]).push(o):Oc(s,e,o.toBytes())||(n.invalid||=[]).push(o);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(n){const o=this._getMessageSignednessErrors(s,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,n=[];Te(n,t.length);const s=n.length+t.length*64+e.length,o=re.Buffer.alloc(s);return ge(t.length<256),re.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(ge(i.length===64,"signature has invalid length"),re.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),ge(o.length<=xt,`Transaction too large: ${o.length} > ${xt}`),o}get keys(){return ge(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return ge(this.instructions.length===1),this.instructions[0].programId}get data(){return ge(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=Ce(t);let s=[];for(let o=0;o<n;o++){const i=Le(t,0,Ks);s.push(we.encode(re.Buffer.from(i)))}return We.populate(tt.from(t),s)}static populate(e,t=[]){const n=new We;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const i={signature:s==we.encode(Kc)?null:we.decode(s),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(s=>{const o=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new Ue({keys:o,programId:e.accountKeys[s.programIdIndex],data:we.decode(s.data)}))}),n._message=e,n._json=n.toJSON(),n}}const Hc=160,$c=64,Wc=Hc/$c,jc=1e3/Wc;new Q("SysvarC1ock11111111111111111111111111111111");new Q("SysvarEpochSchedu1e111111111111111111111111");new Q("Sysvar1nstructions1111111111111111111111111");const On=new Q("SysvarRecentB1ockHashes11111111111111111111"),qr=new Q("SysvarRent111111111111111111111111111111111");new Q("SysvarRewards111111111111111111111111111111");new Q("SysvarS1otHashes111111111111111111111111111");new Q("SysvarS1otHistory11111111111111111111111111");new Q("SysvarStakeHistory1111111111111111111111111");class Fr extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:s}){const o=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){const o=s.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}class V extends Error{constructor({code:e,message:t,data:n},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}function bt(r){return new Promise(e=>setTimeout(e,r))}function Ie(r,e){const t=r.layout.span>=0?r.layout.span:Ws(r,e),n=re.Buffer.alloc(t),s=Object.assign({instruction:r.index},e);return r.layout.encode(s,n),n}const Vc=h.nu64("lamportsPerSignature"),Vs=h.struct([h.u32("version"),h.u32("state"),oe("authorizedPubkey"),oe("nonce"),h.struct([Vc],"feeCalculator")]),Dr=Vs.span;class or{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Vs.decode(me(e),0);return new or({authorizedPubkey:new Q(t.authorizedPubkey),nonce:new Q(t.nonce).toString(),feeCalculator:t.feeCalculator})}}function At(r){const e=h.blob(8,r),t=e.decode.bind(e),n=e.encode.bind(e),s=e,o=nc();return s.decode=(i,a)=>{const c=t(i,a);return o.decode(c)},s.encode=(i,a,c)=>{const f=o.encode(i);return n(f,a,c)},s}const Re=Object.freeze({Create:{index:0,layout:h.struct([h.u32("instruction"),h.ns64("lamports"),h.ns64("space"),oe("programId")])},Assign:{index:1,layout:h.struct([h.u32("instruction"),oe("programId")])},Transfer:{index:2,layout:h.struct([h.u32("instruction"),At("lamports")])},CreateWithSeed:{index:3,layout:h.struct([h.u32("instruction"),oe("base"),wt("seed"),h.ns64("lamports"),h.ns64("space"),oe("programId")])},AdvanceNonceAccount:{index:4,layout:h.struct([h.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:h.struct([h.u32("instruction"),h.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:h.struct([h.u32("instruction"),oe("authorized")])},AuthorizeNonceAccount:{index:7,layout:h.struct([h.u32("instruction"),oe("authorized")])},Allocate:{index:8,layout:h.struct([h.u32("instruction"),h.ns64("space")])},AllocateWithSeed:{index:9,layout:h.struct([h.u32("instruction"),oe("base"),wt("seed"),h.ns64("space"),oe("programId")])},AssignWithSeed:{index:10,layout:h.struct([h.u32("instruction"),oe("base"),wt("seed"),oe("programId")])},TransferWithSeed:{index:11,layout:h.struct([h.u32("instruction"),At("lamports"),wt("seed"),oe("programId")])},UpgradeNonceAccount:{index:12,layout:h.struct([h.u32("instruction")])}});class on{constructor(){}static createAccount(e){const t=Re.Create,n=Ie(t,{lamports:e.lamports,space:e.space,programId:me(e.programId.toBuffer())});return new Ue({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const s=Re.TransferWithSeed;t=Ie(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:me(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Re.Transfer;t=Ie(s,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new Ue({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const s=Re.AssignWithSeed;t=Ie(s,{base:me(e.basePubkey.toBuffer()),seed:e.seed,programId:me(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Re.Assign;t=Ie(s,{programId:me(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Ue({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=Re.CreateWithSeed,n=Ie(t,{base:me(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:me(e.programId.toBuffer())});let s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new Ue({keys:s,programId:this.programId,data:n})}static createNonceAccount(e){const t=new We;"basePubkey"in e&&"seed"in e?t.add(on.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Dr,programId:this.programId})):t.add(on.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Dr,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=Re.InitializeNonceAccount,n=Ie(t,{authorized:me(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:On,isSigner:!1,isWritable:!1},{pubkey:qr,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new Ue(s)}static nonceAdvance(e){const t=Re.AdvanceNonceAccount,n=Ie(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:On,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new Ue(s)}static nonceWithdraw(e){const t=Re.WithdrawNonceAccount,n=Ie(t,{lamports:e.lamports});return new Ue({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:On,isSigner:!1,isWritable:!1},{pubkey:qr,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=Re.AuthorizeNonceAccount,n=Ie(t,{authorized:me(e.newAuthorizedPubkey.toBuffer())});return new Ue({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const s=Re.AllocateWithSeed;t=Ie(s,{base:me(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:me(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Re.Allocate;t=Ie(s,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Ue({keys:n,programId:this.programId,data:t})}}on.programId=new Q("11111111111111111111111111111111");new Q("BPFLoader2111111111111111111111111111111111");function Gc(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Nn,zr;function Zc(){if(zr)return Nn;zr=1;var r=Object.prototype.toString,e=Object.keys||function(n){var s=[];for(var o in n)s.push(o);return s};function t(n,s){var o,i,a,c,f,b,k;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),s);if(k=r.call(n),k==="[object Array]"){for(a="[",i=n.length-1,o=0;o<i;o++)a+=t(n[o],!0)+",";return i>-1&&(a+=t(n[o],!0)),a+"]"}else if(k==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",o=0;o<i;)f=c[o],b=t(n[f],!1),b!==void 0&&(a&&(a+=","),a+=JSON.stringify(f)+":"+b),o++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return s?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return Nn=function(n){var s=t(n,!1);if(s!==void 0)return""+s},Nn}var Yc=Zc(),Mr=Gc(Yc);const Rt=32;function Pn(r){let e=0;for(;r>1;)r/=2,e++;return e}function Xc(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class Jc{constructor(e,t,n,s,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=s,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Pn(Xc(e+Rt+1))-Pn(Rt)-1,n=this.getSlotsInEpoch(t),s=e-(n-Rt);return[t,s]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[s,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Rt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Pn(Rt)):this.slotsPerEpoch}}var Qc=globalThis.fetch;class ea extends mc{constructor(e,t,n){const s=o=>{const i=yc(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,n),this.underlyingSocket=void 0}call(...e){const t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){const t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function ta(r,e){let t;try{t=r.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${r.index}`);return t}const Kr=56;class Hr{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=ta(na,e),n=e.length-Kr;ge(n>=0,"lookup table is invalid"),ge(n%32===0,"lookup table is invalid");const s=n/32,{addresses:o}=h.struct([h.seq(oe(),s,"addresses")]).decode(e.slice(Kr));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new Q(t.authority[0]):void 0,addresses:o.map(i=>new Q(i))}}}const na={index:1,layout:h.struct([h.u32("typeIndex"),At("deactivationSlot"),h.nu64("lastExtendedSlot"),h.u8("lastExtendedStartIndex"),h.u8(),h.seq(oe(),h.offset(h.u8(),-1),"authority")])},ra=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function sa(r){const e=r.match(ra);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[t,n,s,o]=e,i=r.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}const le=Dt(nr(Q),F(),r=>new Q(r)),Gs=rr([F(),ue("base64")]),ir=Dt(nr(re.Buffer),Gs,r=>re.Buffer.from(r[0],"base64")),oa=30*1e3;function ia(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function ce(r){let e,t;if(typeof r=="string")e=r;else if(r){const{commitment:n,...s}=r;e=n,t=s}return{commitment:e,config:t}}function $r(r){return r.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function Zs(r){return Ae([N({jsonrpc:ue("2.0"),id:F(),result:r}),N({jsonrpc:ue("2.0"),id:F(),error:N({code:vt(),message:F(),data:Z(uc())})})])}const ca=Zs(vt());function ne(r){return Dt(Zs(r),ca,e=>"error"in e?e:{...e,result:D(e.result,r)})}function he(r){return ne(N({context:N({slot:_()}),value:r}))}function gn(r){return N({context:N({slot:_()}),value:r})}function qn(r,e){return r===0?new sn({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new Q(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:we.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new tt(e)}const aa=N({foundation:_(),foundationTerm:_(),initial:_(),taper:_(),terminal:_()}),ua=ne(z(M(N({epoch:_(),effectiveSlot:_(),amount:_(),postBalance:_(),commission:Z(M(_()))})))),la=z(N({slot:_(),prioritizationFee:_()})),fa=N({total:_(),validator:_(),foundation:_(),epoch:_()}),da=N({epoch:_(),slotIndex:_(),slotsInEpoch:_(),absoluteSlot:_(),blockHeight:Z(_()),transactionCount:Z(_())}),ha=N({slotsPerEpoch:_(),leaderScheduleSlotOffset:_(),warmup:Fe(),firstNormalEpoch:_(),firstNormalSlot:_()}),ga=Us(F(),z(_())),ft=M(Ae([N({}),F()])),pa=N({err:ft}),ya=ue("receivedSignature"),ba=N({"solana-core":F(),"feature-set":Z(_())}),ma=N({program:F(),programId:le,parsed:vt()}),wa=N({programId:le,accounts:z(le),data:F()}),Wr=he(N({err:M(Ae([N({}),F()])),logs:M(z(F())),accounts:Z(M(z(M(N({executable:Fe(),owner:F(),lamports:_(),data:z(F()),rentEpoch:Z(_())}))))),unitsConsumed:Z(_()),returnData:Z(M(N({programId:F(),data:rr([F(),ue("base64")])}))),innerInstructions:Z(M(z(N({index:_(),instructions:z(Ae([ma,wa]))}))))})),Sa=he(N({byIdentity:Us(F(),z(_())),range:N({firstSlot:_(),lastSlot:_()})}));function Ea(r,e,t,n,s,o){const i=t||Qc;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(b,k)=>{const p=await new Promise((g,E)=>{try{n(b,k,(m,I)=>g([m,I]))}catch(m){E(m)}});return await i(...p)}),new gc(async(b,k)=>{const p={method:"POST",body:b,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},Eu)};try{let g=5,E,m=500;for(;c?E=await c(r,p):E=await i(r,p),!(E.status!==429||s===!0||(g-=1,g===0));)console.error(`Server responded with ${E.status} ${E.statusText}.  Retrying after ${m}ms delay...`),await bt(m),m*=2;const I=await E.text();E.ok?k(null,I):k(new Error(`${E.status} ${E.statusText}: ${I}`))}catch(g){g instanceof Error&&k(g)}},{})}function xa(r){return(e,t)=>new Promise((n,s)=>{r.request(e,t,(o,i)=>{if(o){s(o);return}n(i)})})}function ka(r){return e=>new Promise((t,n)=>{e.length===0&&t([]);const s=e.map(o=>r.request(o.methodName,o.args));r.request(s,(o,i)=>{if(o){n(o);return}t(i)})})}const Ba=ne(aa),_a=ne(fa),Aa=ne(la),va=ne(da),Ia=ne(ha),Ra=ne(ga),Ca=ne(_()),Ta=he(N({total:_(),circulating:_(),nonCirculating:_(),nonCirculatingAccounts:z(le)})),$n=N({amount:F(),uiAmount:M(_()),decimals:_(),uiAmountString:Z(F())}),La=he(z(N({address:le,amount:F(),uiAmount:M(_()),decimals:_(),uiAmountString:Z(F())}))),Ua=he(z(N({pubkey:le,account:N({executable:Fe(),owner:le,lamports:_(),data:ir,rentEpoch:_()})}))),Wn=N({program:F(),parsed:vt(),space:_()}),Oa=he(z(N({pubkey:le,account:N({executable:Fe(),owner:le,lamports:_(),data:Wn,rentEpoch:_()})}))),Na=he(z(N({lamports:_(),address:le}))),Lt=N({executable:Fe(),owner:le,lamports:_(),data:ir,rentEpoch:_()}),Pa=N({pubkey:le,account:Lt}),qa=Dt(Ae([nr(re.Buffer),Wn]),Ae([Gs,Wn]),r=>Array.isArray(r)?D(r,ir):r),jn=N({executable:Fe(),owner:le,lamports:_(),data:qa,rentEpoch:_()}),Fa=N({pubkey:le,account:jn}),Da=N({state:Ae([ue("active"),ue("inactive"),ue("activating"),ue("deactivating")]),active:_(),inactive:_()}),za=ne(z(N({signature:F(),slot:_(),err:ft,memo:M(F()),blockTime:Z(M(_()))}))),Ma=ne(z(N({signature:F(),slot:_(),err:ft,memo:M(F()),blockTime:Z(M(_()))}))),Ka=N({subscription:_(),result:gn(Lt)}),Ha=N({pubkey:le,account:Lt}),$a=N({subscription:_(),result:gn(Ha)}),Wa=N({parent:_(),slot:_(),root:_()}),ja=N({subscription:_(),result:Wa}),Va=Ae([N({type:Ae([ue("firstShredReceived"),ue("completed"),ue("optimisticConfirmation"),ue("root")]),slot:_(),timestamp:_()}),N({type:ue("createdBank"),parent:_(),slot:_(),timestamp:_()}),N({type:ue("frozen"),slot:_(),timestamp:_(),stats:N({numTransactionEntries:_(),numSuccessfulTransactions:_(),numFailedTransactions:_(),maxTransactionsPerEntry:_()})}),N({type:ue("dead"),slot:_(),timestamp:_(),err:F()})]),Ga=N({subscription:_(),result:Va}),Za=N({subscription:_(),result:gn(Ae([pa,ya]))}),Ya=N({subscription:_(),result:_()}),Xa=N({pubkey:F(),gossip:M(F()),tpu:M(F()),rpc:M(F()),version:M(F())}),jr=N({votePubkey:F(),nodePubkey:F(),activatedStake:_(),epochVoteAccount:Fe(),epochCredits:z(rr([_(),_(),_()])),commission:_(),lastVote:_(),rootSlot:M(_())}),Ja=ne(N({current:z(jr),delinquent:z(jr)})),Qa=Ae([ue("processed"),ue("confirmed"),ue("finalized")]),eu=N({slot:_(),confirmations:M(_()),err:ft,confirmationStatus:Z(Qa)}),tu=he(z(M(eu))),nu=ne(_()),Ys=N({accountKey:le,writableIndexes:z(_()),readonlyIndexes:z(_())}),cr=N({signatures:z(F()),message:N({accountKeys:z(F()),header:N({numRequiredSignatures:_(),numReadonlySignedAccounts:_(),numReadonlyUnsignedAccounts:_()}),instructions:z(N({accounts:z(_()),data:F(),programIdIndex:_()})),recentBlockhash:F(),addressTableLookups:Z(z(Ys))})}),Xs=N({pubkey:le,signer:Fe(),writable:Fe(),source:Z(Ae([ue("transaction"),ue("lookupTable")]))}),Js=N({accountKeys:z(Xs),signatures:z(F())}),Qs=N({parsed:vt(),program:F(),programId:le}),eo=N({accounts:z(le),data:F(),programId:le}),ru=Ae([eo,Qs]),su=Ae([N({parsed:vt(),program:F(),programId:F()}),N({accounts:z(F()),data:F(),programId:F()})]),to=Dt(ru,su,r=>"accounts"in r?D(r,eo):D(r,Qs)),no=N({signatures:z(F()),message:N({accountKeys:z(Xs),instructions:z(to),recentBlockhash:F(),addressTableLookups:Z(M(z(Ys)))})}),cn=N({accountIndex:_(),mint:F(),owner:Z(F()),programId:Z(F()),uiTokenAmount:$n}),ro=N({writable:z(le),readonly:z(le)}),pn=N({err:ft,fee:_(),innerInstructions:Z(M(z(N({index:_(),instructions:z(N({accounts:z(_()),data:F(),programIdIndex:_()}))})))),preBalances:z(_()),postBalances:z(_()),logMessages:Z(M(z(F()))),preTokenBalances:Z(M(z(cn))),postTokenBalances:Z(M(z(cn))),loadedAddresses:Z(ro),computeUnitsConsumed:Z(_()),costUnits:Z(_())}),ar=N({err:ft,fee:_(),innerInstructions:Z(M(z(N({index:_(),instructions:z(to)})))),preBalances:z(_()),postBalances:z(_()),logMessages:Z(M(z(F()))),preTokenBalances:Z(M(z(cn))),postTokenBalances:Z(M(z(cn))),loadedAddresses:Z(ro),computeUnitsConsumed:Z(_()),costUnits:Z(_())}),It=Ae([ue(0),ue("legacy")]),dt=N({pubkey:F(),lamports:_(),postBalance:M(_()),rewardType:M(F()),commission:Z(M(_()))}),ou=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),transactions:z(N({transaction:cr,meta:M(pn),version:Z(It)})),rewards:Z(z(dt)),blockTime:M(_()),blockHeight:M(_())}))),iu=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),rewards:Z(z(dt)),blockTime:M(_()),blockHeight:M(_())}))),cu=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),transactions:z(N({transaction:Js,meta:M(pn),version:Z(It)})),rewards:Z(z(dt)),blockTime:M(_()),blockHeight:M(_())}))),au=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),transactions:z(N({transaction:no,meta:M(ar),version:Z(It)})),rewards:Z(z(dt)),blockTime:M(_()),blockHeight:M(_())}))),uu=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),transactions:z(N({transaction:Js,meta:M(ar),version:Z(It)})),rewards:Z(z(dt)),blockTime:M(_()),blockHeight:M(_())}))),lu=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),rewards:Z(z(dt)),blockTime:M(_()),blockHeight:M(_())}))),fu=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),transactions:z(N({transaction:cr,meta:M(pn)})),rewards:Z(z(dt)),blockTime:M(_())}))),Vr=ne(M(N({blockhash:F(),previousBlockhash:F(),parentSlot:_(),signatures:z(F()),blockTime:M(_())}))),Fn=ne(M(N({slot:_(),meta:M(pn),blockTime:Z(M(_())),transaction:cr,version:Z(It)}))),jt=ne(M(N({slot:_(),transaction:no,meta:M(ar),blockTime:Z(M(_())),version:Z(It)}))),du=he(N({blockhash:F(),lastValidBlockHeight:_()})),hu=he(Fe()),gu=N({slot:_(),numTransactions:_(),numSlots:_(),samplePeriodSecs:_()}),pu=ne(z(gu)),yu=he(M(N({feeCalculator:N({lamportsPerSignature:_()})}))),bu=ne(F()),mu=ne(F()),wu=N({err:ft,logs:z(F()),signature:F()}),Su=N({result:gn(wu),subscription:_()}),Eu={"solana-client":"js/1.0.0-maintenance"};class Au{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const f={};return async b=>{const{commitment:k,config:p}=ce(b),g=this._buildArgs([],k,void 0,p),E=Mr(g);return f[E]=f[E]??(async()=>{try{const m=await this._rpcRequest("getBlockHeight",g),I=D(m,ne(_()));if("error"in I)throw new V(I.error,"failed to get block height information");return I.result}finally{delete f[E]}})(),await f[E]}})();let n,s,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,s=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=ia(e),this._rpcWsEndpoint=n||sa(e),this._rpcClient=Ea(e,s,o,i,a,c),this._rpcRequest=xa(this._rpcClient),this._rpcBatchRequest=ka(this._rpcClient),this._rpcWebSocket=new ea(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgs([e.toBase58()],n,void 0,s),i=await this._rpcRequest("getBalance",o),a=D(i,he(_()));if("error"in a)throw new V(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=D(t,ne(M(_())));if("error"in n)throw new V(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=D(e,ne(_()));if("error"in t)throw new V(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=D(e,Ca);if("error"in t)throw new V(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),s=D(n,Ta);if("error"in s)throw new V(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",n),o=D(s,he($n));if("error"in o)throw new V(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",n),o=D(s,he($n));if("error"in o)throw new V(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(e,t,n){const{commitment:s,config:o}=ce(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),f=D(c,Ua);if("error"in f)throw new V(f.error,`failed to get token accounts owned by account ${e.toBase58()}`);return f.result}async getParsedTokenAccountsByOwner(e,t,n){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const o=this._buildArgs(s,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",o),a=D(i,Oa);if("error"in a)throw new V(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",n),o=D(s,Na);if("error"in o)throw new V(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",n),o=D(s,La);if("error"in o)throw new V(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgs([e.toBase58()],n,"base64",s),i=await this._rpcRequest("getAccountInfo",o),a=D(i,he(M(Lt)));if("error"in a)throw new V(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",o),a=D(i,he(M(jn)));if("error"in a)throw new V(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:s}=ce(t),o=e.map(f=>f.toBase58()),i=this._buildArgs([o],n,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=D(a,he(z(M(jn))));if("error"in c)throw new V(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:s}=ce(t),o=e.map(f=>f.toBase58()),i=this._buildArgs([o],n,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=D(a,he(z(M(Lt))));if("error"in c)throw new V(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:s,config:o}=ce(t),i=this._buildArgs([e.toBase58()],s,void 0,{...o,epoch:n??o?.epoch}),a=await this._rpcRequest("getStakeActivation",i),c=D(a,ne(Da));if("error"in c)throw new V(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:s}=ce(t),{encoding:o,...i}=s||{},a=this._buildArgs([e.toBase58()],n,o||"base64",{...i,...i.filters?{filters:$r(i.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),f=z(Pa),b=i.withContext===!0?D(c,he(f)):D(c,ne(f));if("error"in b)throw new V(b.error,`failed to get accounts owned by program ${e.toBase58()}`);return b.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",o),a=D(i,ne(z(Fa)));if("error"in a)throw new V(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){let n;if(typeof e=="string")n=e;else{const o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let s;try{s=we.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return ge(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,s,o=!1;const i=new Promise((c,f)=>{try{n=this.onSignature(t,(k,p)=>{n=void 0;const g={context:p,value:k};c({__type:Je.PROCESSED,response:g})},e);const b=new Promise(k=>{n==null?k():s=this._onSubscriptionStateChange(n,p=>{p==="subscribed"&&k()})});(async()=>{if(await b,o)return;const k=await this.getSignatureStatus(t);if(o||k==null)return;const{context:p,value:g}=k;if(g!=null)if(g?.err)f(g.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(g.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(g.confirmationStatus==="processed"||g.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:Je.PROCESSED,response:{context:p,value:g}})}})()}catch(b){f(b)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:s}}){let o=!1;const i=new Promise(k=>{const p=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let g=await p();if(!o){for(;g<=n;)if(await bt(1e3),o||(g=await p(),o))return;k({__type:Je.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),f=this.getCancellationPromise(t);let b;try{const k=await Promise.race([f,c,i]);if(k.__type===Je.PROCESSED)b=k.response;else throw new Hs(s)}finally{o=!0,a()}return b}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:s,nonceValue:o,signature:i}}){let a=!1;const c=new Promise(g=>{let E=o,m=null;const I=async()=>{try{const{context:C,value:q}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:n});return m=C.slot,q?.nonce}catch{return E}};(async()=>{if(E=await I(),!a)for(;;){if(o!==E){g({__type:Je.NONCE_INVALID,slotInWhichNonceDidAdvance:m});return}if(await bt(2e3),a||(E=await I(),a))return}})()}),{abortConfirmation:f,confirmationPromise:b}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),k=this.getCancellationPromise(t);let p;try{const g=await Promise.race([k,b,c]);if(g.__type===Je.PROCESSED)p=g.response;else{let E;for(;;){const m=await this.getSignatureStatus(i);if(m==null)break;if(m.context.slot<(g.slotInWhichNonceDidAdvance??n)){await bt(400);continue}E=m;break}if(E?.value){const m=e||"finalized",{confirmationStatus:I}=E.value;switch(m){case"processed":case"recent":if(I!=="processed"&&I!=="confirmed"&&I!=="finalized")throw new Ct(i);break;case"confirmed":case"single":case"singleGossip":if(I!=="confirmed"&&I!=="finalized")throw new Ct(i);break;case"finalized":case"max":case"root":if(I!=="finalized")throw new Ct(i);break;default:}p={context:E.context,value:{err:E.value.err}}}else throw new Ct(i)}}finally{a=!0,f()}return p}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const s=new Promise(c=>{let f=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{f=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:Je.TIMED_OUT,timeoutMs:f}),f)}),{abortConfirmation:o,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===Je.PROCESSED)a=c.response;else throw new $s(t,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=D(e,ne(z(Xa)));if("error"in t)throw new V(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),s=D(n,Ja);if("error"in s)throw new V(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:n}=ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlot",s),i=D(o,ne(_()));if("error"in i)throw new V(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getSlotLeader",s),i=D(o,ne(F()));if("error"in i)throw new V(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],s=await this._rpcRequest("getSlotLeaders",n),o=D(s,ne(z(le)));if("error"in o)throw new V(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(e,t){const{context:n,value:s}=await this.getSignatureStatuses([e],t);ge(s.length===1);const o=s[0];return{context:n,value:o}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const s=await this._rpcRequest("getSignatureStatuses",n),o=D(s,tu);if("error"in o)throw new V(o.error,"failed to get signature status");return o.result}async getTransactionCount(e){const{commitment:t,config:n}=ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getTransactionCount",s),i=D(o,ne(_()));if("error"in i)throw new V(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),s=D(n,Ba);if("error"in s)throw new V(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,n){const{commitment:s,config:o}=ce(n),i=this._buildArgs([e.map(f=>f.toBase58())],s,void 0,{...o,epoch:t??o?.epoch}),a=await this._rpcRequest("getInflationReward",i),c=D(a,ua);if("error"in c)throw new V(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=D(e,_a);if("error"in t)throw new V(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getEpochInfo",s),i=D(o,va);if("error"in i)throw new V(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=D(e,Ia);if("error"in t)throw new V(t.error,"failed to get epoch schedule");const n=t.result;return new Jc(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=D(e,Ra);if("error"in t)throw new V(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=D(s,nu);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(e){const{context:t,value:{blockhash:n}}=await this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:n,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=D(t,pu);if("error"in n)throw new V(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=D(s,yu);if("error"in o)throw new V(o.error,"failed to get fee calculator");const{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=me(e.serialize()).toString("base64"),s=this._buildArgs([n],t),o=await this._rpcRequest("getFeeForMessage",s),i=D(o,he(M(_())));if("error"in i)throw new V(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){const t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),n=t?.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",n),o=D(s,Aa);if("error"in o)throw new V(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=ce(e),s=this._buildArgs([],t,void 0,n),o=await this._rpcRequest("getLatestBlockhash",s),i=D(o,du);if("error"in i)throw new V(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgs([e],n,void 0,s),i=await this._rpcRequest("isBlockhashValid",o),a=D(i,hu);if("error"in a)throw new V(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=D(e,ne(ba));if("error"in t)throw new V(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=D(e,ne(F()));if("error"in t)throw new V(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=D(i,cu);if("error"in a)throw a.error;return a.result}case"none":{const a=D(i,iu);if("error"in a)throw a.error;return a.result}default:{const a=D(i,ou);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:f,meta:b,version:k})=>({meta:b,transaction:{...f,message:qn(k,f.message)},version:k}))}:null}}}catch(a){throw new V(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getBlock",o);try{switch(s?.transactionDetails){case"accounts":{const a=D(i,uu);if("error"in a)throw a.error;return a.result}case"none":{const a=D(i,lu);if("error"in a)throw a.error;return a.result}default:{const a=D(i,au);if("error"in a)throw a.error;return a.result}}}catch(a){throw new V(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const s=this._buildArgs([],n,"base64",t),o=await this._rpcRequest("getBlockProduction",s),i=D(o,Sa);if("error"in i)throw new V(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,s),i=await this._rpcRequest("getTransaction",o),a=D(i,Fn);if("error"in a)throw new V(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:qn(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:s}=ce(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",s),i=await this._rpcRequest("getTransaction",o),a=D(i,jt);if("error"in a)throw new V(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:s}=ce(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",s)}));return(await this._rpcBatchRequest(o)).map(c=>{const f=D(c,jt);if("error"in f)throw new V(f.error,"failed to get transactions");return f.result})}async getTransactions(e,t){const{commitment:n,config:s}=ce(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,s)}));return(await this._rpcBatchRequest(o)).map(c=>{const f=D(c,Fn);if("error"in f)throw new V(f.error,"failed to get transactions");const b=f.result;return b&&{...b,transaction:{...b.transaction,message:qn(b.version,b.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getBlock",n),o=D(s,fu);if("error"in o)throw new V(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:f})=>{const b=new tt(c.message);return{meta:f,transaction:{...c,message:b}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:f})=>({meta:f,transaction:We.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=await this._rpcRequest("getBlocks",s),i=D(o,ne(z(_())));if("error"in i)throw new V(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=D(s,Vr);if("error"in o)throw new V(o.error,"failed to get block");const i=o.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",n),o=D(s,Vr);if("error"in o)throw new V(o.error,"failed to get confirmed block");const i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getTransaction",n),o=D(s,Fn);if("error"in o)throw new V(o.error,"failed to get transaction");const i=o.result;if(!i)return i;const a=new tt(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:We.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getTransaction",n),o=D(s,jt);if("error"in o)throw new V(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=D(i,jt);if("error"in a)throw new V(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let s={},o=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<o));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=D(o,za);if("error"in i)throw new V(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=await this._rpcRequest("getSignaturesForAddress",s),i=D(o,Ma);if("error"in i)throw new V(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=new Hr({key:e,state:Hr.deserialize(s.data)})),{context:n,value:o}}async getNonceAndContext(e,t){const{context:n,value:s}=await this.getAccountInfoAndContext(e,t);let o=null;return s!==null&&(o=or.fromAccountData(s.data)),{context:n,value:o}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=D(n,bu);if("error"in s)throw new V(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await bt(100);const n=Date.now()-this._blockhashInfo.lastFetch>=oa;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let s=0;s<50;s++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await bt(jc/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=ce(e),s=this._buildArgs([],t,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",s),i=D(o,he(_()));if("error"in i)throw new V(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const m=e.serialize(),I=re.Buffer.from(m).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const C=t||{};C.encoding="base64","commitment"in C||(C.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(C.innerInstructions=t.innerInstructions);const q=[I,C],U=await this._rpcRequest("simulateTransaction",q),H=D(U,Wr);if("error"in H)throw new Error("failed to simulate transaction: "+H.error.message);return H.result}let s;if(e instanceof We){let E=e;s=new We,s.feePayer=E.feePayer,s.instructions=e.instructions,s.nonceInfo=E.nonceInfo,s.signatures=E.signatures}else s=We.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const o=t;if(s.nonceInfo&&o)s.sign(...o);else{let E=this._disableBlockhashCaching;for(;;){const m=await this._blockhashWithExpiryBlockHeight(E);if(s.lastValidBlockHeight=m.lastValidBlockHeight,s.recentBlockhash=m.blockhash,!o)break;if(s.sign(...o),!s.signature)throw new Error("!signature");const I=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(I)&&!this._blockhashInfo.transactionSignatures.includes(I)){this._blockhashInfo.simulatedSignatures.push(I);break}else E=!0}}const i=s._compile(),a=i.serialize(),f=s._serialize(a).toString("base64"),b={encoding:"base64",commitment:this.commitment};if(n){const E=(Array.isArray(n)?n:i.nonProgramIds()).map(m=>m.toBase58());b.accounts={encoding:"base64",addresses:E}}o&&(b.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(b.innerInstructions=t.innerInstructions);const k=[f,b],p=await this._rpcRequest("simulateTransaction",k),g=D(p,Wr);if("error"in g){let E;if("data"in g.error&&(E=g.error.data.logs,E&&Array.isArray(E))){const m=`
    `,I=m+E.join(m);console.error(g.error.message,I)}throw new Fr({action:"simulate",signature:"",transactionMessage:g.error.message,logs:E})}return g.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=e.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(e,t){const n=me(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},s=t&&t.skipPreflight,o=s===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),s&&(n.skipPreflight=s),o&&(n.preflightCommitment=o);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=D(a,mu);if("error"in c){let f;throw"data"in c.error&&(f=c.error.data.logs),new Fr({action:s?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:f})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){const n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const s=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const s=this._subscriptionsByHash[n];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[n],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:i}=s;try{this._setSubscription(n,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,o);this._setSubscription(n,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:o,error:a}),!t())return;this._setSubscription(n,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...s,state:"unsubscribing"}),this._setSubscription(n,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(s=>{try{s(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=D(e,Ka);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,s=Mr([e.method,t]),o=this._subscriptionsByHash[s];return o===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[s];ge(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:s,config:o}=ce(n),i=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=D(e,$a);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,s){const{commitment:o,config:i}=ce(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(s?{filters:$r(s)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=D(e,Su);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=D(e,ja);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=D(e,Ga);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,s){const o=t||this._commitment;if(o||n||s){let i={};n&&(i.encoding=n),o&&(i.commitment=o),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,s){const o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,s)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=D(e,Za);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const s=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return o}onSignatureWithOptions(e,t,n){const{commitment:s,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,o),a=this._makeSubscription({callback:(c,f)=>{t(c,f);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=D(e,Ya);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}Object.freeze({CreateLookupTable:{index:0,layout:h.struct([h.u32("instruction"),At("recentSlot"),h.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:h.struct([h.u32("instruction")])},ExtendLookupTable:{index:2,layout:h.struct([h.u32("instruction"),At(),h.seq(oe(),h.offset(h.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:h.struct([h.u32("instruction")])},CloseLookupTable:{index:4,layout:h.struct([h.u32("instruction")])}});new Q("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:h.struct([h.u8("instruction"),h.u32("units"),h.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:h.struct([h.u8("instruction"),h.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:h.struct([h.u8("instruction"),h.u32("units")])},SetComputeUnitPrice:{index:3,layout:h.struct([h.u8("instruction"),At("microLamports")])}});new Q("ComputeBudget111111111111111111111111111111");h.struct([h.u8("numSignatures"),h.u8("padding"),h.u16("signatureOffset"),h.u16("signatureInstructionIndex"),h.u16("publicKeyOffset"),h.u16("publicKeyInstructionIndex"),h.u16("messageDataOffset"),h.u16("messageDataSize"),h.u16("messageInstructionIndex")]);new Q("Ed25519SigVerify111111111111111111111111111");Lc.utils.isValidPrivateKey;h.struct([h.u8("numSignatures"),h.u16("signatureOffset"),h.u8("signatureInstructionIndex"),h.u16("ethAddressOffset"),h.u8("ethAddressInstructionIndex"),h.u16("messageDataOffset"),h.u16("messageDataSize"),h.u8("messageInstructionIndex"),h.blob(20,"ethAddress"),h.blob(64,"signature"),h.u8("recoveryId")]);new Q("KeccakSecp256k11111111111111111111111111111");var so;new Q("StakeConfig11111111111111111111111111111111");class oo{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}so=oo;oo.default=new so(0,0,Q.default);Object.freeze({Initialize:{index:0,layout:h.struct([h.u32("instruction"),Fc(),Dc()])},Authorize:{index:1,layout:h.struct([h.u32("instruction"),oe("newAuthorized"),h.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:h.struct([h.u32("instruction")])},Split:{index:3,layout:h.struct([h.u32("instruction"),h.ns64("lamports")])},Withdraw:{index:4,layout:h.struct([h.u32("instruction"),h.ns64("lamports")])},Deactivate:{index:5,layout:h.struct([h.u32("instruction")])},Merge:{index:7,layout:h.struct([h.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:h.struct([h.u32("instruction"),oe("newAuthorized"),h.u32("stakeAuthorizationType"),wt("authoritySeed"),oe("authorityOwner")])}});new Q("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:h.struct([h.u32("instruction"),zc()])},Authorize:{index:1,layout:h.struct([h.u32("instruction"),oe("newAuthorized"),h.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:h.struct([h.u32("instruction"),h.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:h.struct([h.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:h.struct([h.u32("instruction"),Mc()])}});new Q("Vote111111111111111111111111111111111111111");new Q("Va1idator1nfo111111111111111111111111111111");N({name:F(),website:Z(F()),details:Z(F()),iconUrl:Z(F()),keybaseUsername:Z(F())});new Q("Vote111111111111111111111111111111111111111");h.struct([oe("nodePubkey"),oe("authorizedWithdrawer"),h.u8("commission"),h.nu64(),h.seq(h.struct([h.nu64("slot"),h.u32("confirmationCount")]),h.offset(h.u32(),-8),"votes"),h.u8("rootSlotValid"),h.nu64("rootSlot"),h.nu64(),h.seq(h.struct([h.nu64("epoch"),oe("authorizedVoter")]),h.offset(h.u32(),-8),"authorizedVoters"),h.struct([h.seq(h.struct([oe("authorizedPubkey"),h.nu64("epochOfLastAuthorizedSwitch"),h.nu64("targetEpoch")]),32,"buf"),h.nu64("idx"),h.u8("isEmpty")],"priorVoters"),h.nu64(),h.seq(h.struct([h.nu64("epoch"),h.nu64("credits"),h.nu64("prevCredits")]),h.offset(h.u32(),-8),"epochCredits"),h.struct([h.nu64("slot"),h.nu64("timestamp")],"lastTimestamp")]);const Gr={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function vu(r,e){const t=e===!1?"http":"https";if(!r)return Gr[t].devnet;const n=Gr[t][r];if(!n)throw new Error(`Unknown ${t} cluster: ${r}`);return n}export{Hr as AddressLookupTableAccount,oa as BLOCKHASH_CACHE_TIMEOUT_MS,Au as Connection,Jc as EpochSchedule,Vc as FeeCalculatorLayout,oo as Lockup,Pc as MAX_SEED_LENGTH,tt as Message,rn as MessageAccountKeys,sn as MessageV0,Dr as NONCE_ACCOUNT_LENGTH,or as NonceAccount,xt as PACKET_DATA_SIZE,et as PUBLIC_KEY_LENGTH,Q as PublicKey,Ks as SIGNATURE_LENGTH_IN_BYTES,Vt as SOLANA_SCHEMA,Re as SYSTEM_INSTRUCTION_LAYOUTS,On as SYSVAR_RECENT_BLOCKHASHES_PUBKEY,qr as SYSVAR_RENT_PUBKEY,Fr as SendTransactionError,V as SolanaJSONRPCError,Nc as Struct,on as SystemProgram,We as Transaction,Hs as TransactionExpiredBlockheightExceededError,Ct as TransactionExpiredNonceInvalidError,$s as TransactionExpiredTimeoutError,Ue as TransactionInstruction,Je as TransactionStatus,Ms as VERSION_PREFIX_MASK,vu as clusterApiUrl};
